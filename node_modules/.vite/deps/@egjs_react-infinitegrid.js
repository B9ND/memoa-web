import {
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/@egjs/react-infinitegrid/dist/infinitegrid.esm.js
var import_react = __toESM(require_react());

// node_modules/@egjs/component/dist/component.esm.js
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}
var isUndefined = function(value) {
  return typeof value === "undefined";
};
var ComponentEvent = function() {
  function ComponentEvent2(eventType, props) {
    var e_1, _a;
    this._canceled = false;
    if (props) {
      try {
        for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          this[key] = props[key];
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    this.eventType = eventType;
  }
  var __proto = ComponentEvent2.prototype;
  __proto.stop = function() {
    this._canceled = true;
  };
  __proto.isCanceled = function() {
    return this._canceled;
  };
  return ComponentEvent2;
}();
var Component = function() {
  function Component3() {
    this._eventHandler = {};
  }
  var __proto = Component3.prototype;
  __proto.trigger = function(event) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      params[_i - 1] = arguments[_i];
    }
    var eventName = event instanceof ComponentEvent ? event.eventType : event;
    var handlers = __spread(this._eventHandler[eventName] || []);
    if (handlers.length <= 0) {
      return this;
    }
    if (event instanceof ComponentEvent) {
      event.currentTarget = this;
      handlers.forEach(function(handler) {
        handler(event);
      });
    } else {
      handlers.forEach(function(handler) {
        handler.apply(void 0, __spread(params));
      });
    }
    return this;
  };
  __proto.once = function(eventName, handlerToAttach) {
    var _this = this;
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var key in eventHash) {
        this.once(key, eventHash[key]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var listener_1 = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        handlerToAttach.apply(void 0, __spread(args));
        _this.off(eventName, listener_1);
      };
      this.on(eventName, listener_1);
    }
    return this;
  };
  __proto.hasOn = function(eventName) {
    return !!this._eventHandler[eventName];
  };
  __proto.on = function(eventName, handlerToAttach) {
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var name in eventHash) {
        this.on(name, eventHash[name]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var handlerList = this._eventHandler[eventName];
      if (isUndefined(handlerList)) {
        this._eventHandler[eventName] = [];
        handlerList = this._eventHandler[eventName];
      }
      handlerList.push(handlerToAttach);
    }
    return this;
  };
  __proto.off = function(eventName, handlerToDetach) {
    if (isUndefined(eventName)) {
      this._eventHandler = {};
      return this;
    }
    if (isUndefined(handlerToDetach)) {
      if (typeof eventName === "string") {
        delete this._eventHandler[eventName];
        return this;
      } else {
        var eventHash = eventName;
        for (var name in eventHash) {
          this.off(name, eventHash[name]);
        }
        return this;
      }
    }
    var handlerList = this._eventHandler[eventName];
    if (handlerList) {
      var length2 = handlerList.length;
      for (var i = 0; i < length2; ++i) {
        if (handlerList[i] === handlerToDetach) {
          handlerList.splice(i, 1);
          if (length2 <= 1) {
            delete this._eventHandler[eventName];
          }
          break;
        }
      }
    }
    return this;
  };
  Component3.VERSION = "3.0.5";
  return Component3;
}();
var ComponentEvent$1 = ComponentEvent;
var component_esm_default = Component;

// node_modules/@egjs/list-differ/dist/list-differ.esm.js
var PolyMap = function() {
  function PolyMap2() {
    this.keys = [];
    this.values = [];
  }
  var __proto = PolyMap2.prototype;
  __proto.get = function(key) {
    return this.values[this.keys.indexOf(key)];
  };
  __proto.set = function(key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };
  return PolyMap2;
}();
var HashMap = function() {
  function HashMap2() {
    this.object = {};
  }
  var __proto = HashMap2.prototype;
  __proto.get = function(key) {
    return this.object[key];
  };
  __proto.set = function(key, value) {
    this.object[key] = value;
  };
  return HashMap2;
}();
var SUPPORT_MAP = typeof Map === "function";
var Link = function() {
  function Link2() {
  }
  var __proto = Link2.prototype;
  __proto.connect = function(prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };
  __proto.disconnect = function() {
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };
  __proto.getIndex = function() {
    var link = this;
    var index = -1;
    while (link) {
      link = link.prev;
      ++index;
    }
    return index;
  };
  return Link2;
}();
function orderChanged(changed, fixed) {
  var fromLinks = [];
  var toLinks = [];
  changed.forEach(function(_a) {
    var from = _a[0], to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  });
  fromLinks.forEach(function(link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function(_, i) {
    return !fixed[i];
  }).map(function(_a, i) {
    var from = _a[0], to = _a[1];
    if (from === to) {
      return [0, 0];
    }
    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex();
    fromLink.disconnect();
    if (!toLink) {
      fromLink.connect(void 0, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }
    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}
var Result = function() {
  function Result2(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }
  var __proto = Result2.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function() {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }
      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function() {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }
      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });
  __proto.caculateOrdered = function() {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function(_a, i) {
      var from = _a[0], to = _a[1];
      var _b = changed[i], fromBefore = _b[0], toBefore = _b[1];
      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };
  return Result2;
}();
function diff(prevList, list, findKeyCallback2) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback2 ? HashMap : PolyMap;
  var callback = findKeyCallback2 || function(e) {
    return e;
  };
  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0;
  prevKeys.forEach(function(key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function(key, listIndex) {
    keyMap.set(key, listIndex);
  });
  prevKeys.forEach(function(key, prevListIndex) {
    var listIndex = keyMap.get(key);
    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  });
  keys.forEach(function(key, listIndex) {
    var prevListIndex = prevKeyMap.get(key);
    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);
      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  });
  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}
var ListDiffer = function() {
  function ListDiffer2(list, findKeyCallback2) {
    if (list === void 0) {
      list = [];
    }
    this.findKeyCallback = findKeyCallback2;
    this.list = [].slice.call(list);
  }
  var __proto = ListDiffer2.prototype;
  __proto.update = function(list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };
  return ListDiffer2;
}();
var list_differ_esm_default = ListDiffer;

// node_modules/@egjs/children-differ/dist/children-differ.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var findKeyCallback = typeof Map === "function" ? void 0 : /* @__PURE__ */ function() {
  var childrenCount = 0;
  return function(el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();
var ChildrenDiffer = function(_super) {
  __extends(ChildrenDiffer2, _super);
  function ChildrenDiffer2(list) {
    if (list === void 0) {
      list = [];
    }
    return _super.call(this, list, findKeyCallback) || this;
  }
  return ChildrenDiffer2;
}(list_differ_esm_default);
function diff2(prevList, list) {
  return diff(prevList, list, findKeyCallback);
}

// node_modules/@egjs/imready/node_modules/@cfcs/core/dist/cfcs.esm.js
var CFCS_DETECTED_DEPENDENCIES_VERSION = 1;
var CFCS_DETECTED_DEPENDENCIES = "__CFCS_DETECTED_DEPENDENCIES__";
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function getDetectedStack() {
  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};
  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];
  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];
  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];
}
function getCurrentDetected() {
  var stack = getDetectedStack();
  return stack[stack.length - 1];
}
function detectDependencies(host) {
  var stack = getDetectedStack();
  var observers = [];
  var detected = {
    host,
    observers,
    push: function(observer) {
      if (host !== observer && observers.indexOf(observer) === -1) {
        observers.push(observer);
      }
    }
  };
  stack.push(detected);
  return detected;
}
function endDetectDependencies() {
  var stack = getDetectedStack();
  return stack.pop();
}
var Observer = function() {
  function Observer3(value) {
    this._emitter = new component_esm_default();
    this._current = value;
  }
  var __proto = Observer3.prototype;
  Object.defineProperty(__proto, "current", {
    /**
     * return the current value.
     */
    get: function() {
      var currentDetected = getCurrentDetected();
      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);
      return this._current;
    },
    set: function(value) {
      this._setCurrent(value);
    },
    enumerable: false,
    configurable: true
  });
  __proto.subscribe = function(callback) {
    this.current;
    this._emitter.on("update", callback);
    return this;
  };
  __proto.unsubscribe = function(callback) {
    this._emitter.off("update", callback);
    return this;
  };
  __proto._setCurrent = function(value) {
    var prevValue = this._current;
    var isUpdate = value !== prevValue;
    this._current = value;
    if (isUpdate) {
      this._emitter.trigger("update", value, prevValue);
    }
  };
  __proto.toString = function() {
    return "".concat(this.current);
  };
  __proto.valueOf = function() {
    return this.current;
  };
  return Observer3;
}();
var ComputedObserver = function(_super) {
  __extends2(ComputedObserver2, _super);
  function ComputedObserver2(_computedCallback) {
    var _this = _super.call(this) || this;
    _this._computedCallback = _computedCallback;
    _this._registered = [];
    _this._onCheckUpdate = function() {
      _this._setCurrent(_this.current);
    };
    _this._current = _this.current;
    return _this;
  }
  var __proto = ComputedObserver2.prototype;
  Object.defineProperty(__proto, "current", {
    get: function() {
      var _this = this;
      detectDependencies(this);
      var value = this._computedCallback();
      var results = endDetectDependencies();
      this._registered.forEach(function(observer) {
        observer.unsubscribe(_this._onCheckUpdate);
      });
      results.observers.forEach(function(observer) {
        observer.subscribe(_this._onCheckUpdate);
      });
      this._registered = results.observers;
      return value;
    },
    enumerable: false,
    configurable: true
  });
  return ComputedObserver2;
}(Observer);

// node_modules/@egjs/imready/dist/imready.esm.js
var extendStatics3 = function(d, b) {
  extendStatics3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics3(d, b);
};
function __extends3(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
var isWindow = typeof window !== "undefined";
var ua = isWindow ? window.navigator.userAgent : "";
var SUPPORT_COMPUTEDSTYLE = isWindow ? !!("getComputedStyle" in window) : false;
var IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);
var SUPPORT_ADDEVENTLISTENER = isWindow ? !!("addEventListener" in document) : false;
var WIDTH = "width";
var HEIGHT = "height";
function getAttribute(el, name) {
  return el.getAttribute(name) || "";
}
function toArray(arr) {
  return [].slice.call(arr);
}
function hasSizeAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }
  return !!target.getAttribute(prefix + "width");
}
function hasLoadingAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }
  return "loading" in target && target.getAttribute("loading") === "lazy" || !!target.getAttribute(prefix + "lazy");
}
function hasSkipAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }
  return !!target.getAttribute(prefix + "skip");
}
function addEvent(element, type, handler) {
  if (SUPPORT_ADDEVENTLISTENER) {
    element.addEventListener(type, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent("on" + type, handler);
  } else {
    element["on" + type] = handler;
  }
}
function removeEvent(element, type, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent("on" + type, handler);
  } else {
    element["on" + type] = null;
  }
}
function innerWidth(el) {
  return getSize(el, "Width");
}
function innerHeight(el) {
  return getSize(el, "Height");
}
function getStyles(el) {
  return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};
}
function getSize(el, name) {
  var size = el["client" + name] || el["offset" + name];
  return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;
}
function getContentElements(element, tags, prefix) {
  var skipElements = toArray(element.querySelectorAll(__spreadArrays(["[" + prefix + "skip] [" + prefix + "width]"], tags.map(function(tag) {
    return ["[" + prefix + "skip] " + tag, tag + "[" + prefix + "skip]", "[" + prefix + "width] " + tag].join(", ");
  })).join(", ")));
  return toArray(element.querySelectorAll("[" + prefix + "width], " + tags.join(", "))).filter(function(el) {
    return skipElements.indexOf(el) === -1;
  });
}
var elements = [];
function addAutoSizer(element, prefix) {
  !elements.length && addEvent(window, "resize", resizeAllAutoSizers);
  element.__PREFIX__ = prefix;
  elements.push(element);
  resize(element);
}
function removeAutoSizer(element, prefix) {
  var index = elements.indexOf(element);
  if (index < 0) {
    return;
  }
  var fixed = getAttribute(element, prefix + "fixed");
  delete element.__PREFIX__;
  element.style[fixed === HEIGHT ? WIDTH : HEIGHT] = "";
  elements.splice(index, 1);
  !elements.length && removeEvent(window, "resize", resizeAllAutoSizers);
}
function resize(element, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }
  var elementPrefix = element.__PREFIX__ || prefix;
  var dataWidth = parseInt(getAttribute(element, "" + elementPrefix + WIDTH), 10) || 0;
  var dataHeight = parseInt(getAttribute(element, "" + elementPrefix + HEIGHT), 10) || 0;
  var fixed = getAttribute(element, elementPrefix + "fixed");
  if (fixed === HEIGHT) {
    var size = innerHeight(element) || dataHeight;
    element.style[WIDTH] = dataWidth / dataHeight * size + "px";
  } else {
    var size = innerWidth(element) || dataWidth;
    element.style[HEIGHT] = dataHeight / dataWidth * size + "px";
  }
}
function resizeAllAutoSizers() {
  elements.forEach(function(element) {
    resize(element);
  });
}
var Loader = function(_super) {
  __extends3(Loader2, _super);
  function Loader2(element, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.isReady = false;
    _this.isPreReady = false;
    _this.hasDataSize = false;
    _this.hasLoading = false;
    _this.isSkip = false;
    _this.onCheck = function(e) {
      _this.clear();
      if (e && e.type === "error") {
        _this.onError(_this.element);
      }
      if (_this.hasLoading && _this.checkElement()) {
        return;
      }
      var withPreReady = !_this.hasDataSize && !_this.hasLoading;
      _this.onReady(withPreReady);
    };
    _this.options = __assign({
      prefix: "data-"
    }, options);
    _this.element = element;
    var prefix = _this.options.prefix;
    _this.hasDataSize = hasSizeAttribute(element, prefix);
    _this.isSkip = hasSkipAttribute(element, prefix);
    _this.hasLoading = hasLoadingAttribute(element, prefix);
    return _this;
  }
  var __proto = Loader2.prototype;
  __proto.check = function() {
    if (this.isSkip || !this.checkElement()) {
      this.onAlreadyReady(true);
      return false;
    }
    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
    }
    if (this.hasDataSize || this.hasLoading) {
      this.onAlreadyPreReady();
    }
    return true;
  };
  __proto.addEvents = function() {
    var _this = this;
    var element = this.element;
    this.constructor.EVENTS.forEach(function(name) {
      addEvent(element, name, _this.onCheck);
    });
  };
  __proto.clear = function() {
    var _this = this;
    var element = this.element;
    this.constructor.EVENTS.forEach(function(name) {
      removeEvent(element, name, _this.onCheck);
    });
    this.removeAutoSizer();
  };
  __proto.destroy = function() {
    this.clear();
    this.off();
  };
  __proto.removeAutoSizer = function() {
    if (this.hasDataSize) {
      var prefix = this.options.prefix;
      removeAutoSizer(this.element, prefix);
    }
  };
  __proto.onError = function(target) {
    this.trigger("error", {
      element: this.element,
      target
    });
  };
  __proto.onPreReady = function() {
    if (this.isPreReady) {
      return;
    }
    this.isPreReady = true;
    this.trigger("preReady", {
      element: this.element,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };
  __proto.onReady = function(withPreReady) {
    if (this.isReady) {
      return;
    }
    withPreReady = !this.isPreReady && withPreReady;
    if (withPreReady) {
      this.isPreReady = true;
    }
    this.removeAutoSizer();
    this.isReady = true;
    this.trigger("ready", {
      element: this.element,
      withPreReady,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };
  __proto.onAlreadyError = function(target) {
    var _this = this;
    setTimeout(function() {
      _this.onError(target);
    });
  };
  __proto.onAlreadyPreReady = function() {
    var _this = this;
    setTimeout(function() {
      _this.onPreReady();
    });
  };
  __proto.onAlreadyReady = function(withPreReady) {
    var _this = this;
    setTimeout(function() {
      _this.onReady(withPreReady);
    });
  };
  Loader2.EVENTS = [];
  return Loader2;
}(component_esm_default);
var ElementLoader = function(_super) {
  __extends3(ElementLoader2, _super);
  function ElementLoader2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = ElementLoader2.prototype;
  __proto.setHasLoading = function(hasLoading) {
    this.hasLoading = hasLoading;
  };
  __proto.check = function() {
    if (this.isSkip) {
      this.onAlreadyReady(true);
      return false;
    }
    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
      this.onAlreadyPreReady();
    } else {
      this.trigger("requestChildren");
    }
    return true;
  };
  __proto.checkElement = function() {
    return true;
  };
  __proto.destroy = function() {
    this.clear();
    this.trigger("requestDestroy");
    this.off();
  };
  __proto.onAlreadyPreReady = function() {
    _super.prototype.onAlreadyPreReady.call(this);
    this.trigger("reqeustReadyChildren");
  };
  ElementLoader2.EVENTS = [];
  return ElementLoader2;
}(Loader);
var ImReadyManager = function(_super) {
  __extends3(ImReadyManager2, _super);
  function ImReadyManager2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.readyCount = 0;
    _this.preReadyCount = 0;
    _this.totalCount = 0;
    _this.totalErrorCount = 0;
    _this.isPreReadyOver = true;
    _this.elementInfos = [];
    _this.options = __assign({
      loaders: {},
      prefix: "data-"
    }, options);
    return _this;
  }
  var __proto = ImReadyManager2.prototype;
  __proto.check = function(elements2) {
    var _this = this;
    var prefix = this.options.prefix;
    this.clear();
    this.elementInfos = toArray(elements2).map(function(element, index) {
      var loader = _this.getLoader(element, {
        prefix
      });
      loader.check();
      loader.on("error", function(e) {
        _this.onError(index, e.target);
      }).on("preReady", function(e) {
        var info = _this.elementInfos[index];
        info.hasLoading = e.hasLoading;
        info.isSkip = e.isSkip;
        var isPreReady = _this.checkPreReady(index);
        _this.onPreReadyElement(index);
        isPreReady && _this.onPreReady();
      }).on("ready", function(_a) {
        var withPreReady = _a.withPreReady, hasLoading = _a.hasLoading, isSkip = _a.isSkip;
        var info = _this.elementInfos[index];
        info.hasLoading = hasLoading;
        info.isSkip = isSkip;
        var isPreReady = withPreReady && _this.checkPreReady(index);
        var isReady = _this.checkReady(index);
        withPreReady && _this.onPreReadyElement(index);
        _this.onReadyElement(index);
        isPreReady && _this.onPreReady();
        isReady && _this.onReady();
      });
      return {
        loader,
        element,
        hasLoading: false,
        hasError: false,
        isPreReady: false,
        isReady: false,
        isSkip: false
      };
    });
    var length2 = this.elementInfos.length;
    this.totalCount = length2;
    if (!length2) {
      setTimeout(function() {
        _this.onPreReady();
        _this.onReady();
      });
    }
    return this;
  };
  __proto.getTotalCount = function() {
    return this.totalCount;
  };
  __proto.isPreReady = function() {
    return this.elementInfos.every(function(info) {
      return info.isPreReady;
    });
  };
  __proto.isReady = function() {
    return this.elementInfos.every(function(info) {
      return info.isReady;
    });
  };
  __proto.hasError = function() {
    return this.totalErrorCount > 0;
  };
  __proto.clear = function() {
    this.isPreReadyOver = false;
    this.totalCount = 0;
    this.preReadyCount = 0;
    this.readyCount = 0;
    this.totalErrorCount = 0;
    this.elementInfos.forEach(function(info) {
      if (info.loader) {
        info.loader.destroy();
      }
    });
    this.elementInfos = [];
  };
  __proto.destroy = function() {
    this.clear();
    this.off();
  };
  __proto.getLoader = function(element, options) {
    var _this = this;
    var tagName = element.tagName.toLowerCase();
    var loaders = this.options.loaders;
    var prefix = options.prefix;
    var tags = Object.keys(loaders);
    if (loaders[tagName]) {
      return new loaders[tagName](element, options);
    }
    var loader = new ElementLoader(element, options);
    var children = toArray(element.querySelectorAll(tags.join(", ")));
    loader.setHasLoading(children.some(function(el) {
      return hasLoadingAttribute(el, prefix);
    }));
    var withPreReady = false;
    var childrenImReady = this.clone().on("error", function(e) {
      loader.onError(e.target);
    }).on("ready", function() {
      loader.onReady(withPreReady);
    });
    loader.on("requestChildren", function() {
      var contentElements = getContentElements(element, tags, _this.options.prefix);
      childrenImReady.check(contentElements).on("preReady", function(e) {
        withPreReady = e.isReady;
        if (!withPreReady) {
          loader.onPreReady();
        }
      });
    }).on("reqeustReadyChildren", function() {
      childrenImReady.check(children);
    }).on("requestDestroy", function() {
      childrenImReady.destroy();
    });
    return loader;
  };
  __proto.clone = function() {
    return new ImReadyManager2(__assign({}, this.options));
  };
  __proto.checkPreReady = function(index) {
    this.elementInfos[index].isPreReady = true;
    ++this.preReadyCount;
    if (this.preReadyCount < this.totalCount) {
      return false;
    }
    return true;
  };
  __proto.checkReady = function(index) {
    this.elementInfos[index].isReady = true;
    ++this.readyCount;
    if (this.readyCount < this.totalCount) {
      return false;
    }
    return true;
  };
  __proto.onError = function(index, target) {
    var info = this.elementInfos[index];
    info.hasError = true;
    this.trigger(new ComponentEvent$1("error", {
      element: info.element,
      index,
      target,
      errorCount: this.getErrorCount(),
      totalErrorCount: ++this.totalErrorCount
    }));
  };
  __proto.onPreReadyElement = function(index) {
    var info = this.elementInfos[index];
    this.trigger(new ComponentEvent$1("preReadyElement", {
      element: info.element,
      index,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isSkip: info.isSkip
    }));
  };
  __proto.onPreReady = function() {
    this.isPreReadyOver = true;
    this.trigger(new ComponentEvent$1("preReady", {
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isReady: this.isReady(),
      hasLoading: this.hasLoading()
    }));
  };
  __proto.onReadyElement = function(index) {
    var info = this.elementInfos[index];
    this.trigger(new ComponentEvent$1("readyElement", {
      index,
      element: info.element,
      hasError: info.hasError,
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isPreReadyOver: this.isPreReadyOver,
      isSkip: info.isSkip
    }));
  };
  __proto.onReady = function() {
    this.trigger(new ComponentEvent$1("ready", {
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      totalCount: this.totalCount
    }));
  };
  __proto.getErrorCount = function() {
    return this.elementInfos.filter(function(info) {
      return info.hasError;
    }).length;
  };
  __proto.hasLoading = function() {
    return this.elementInfos.some(function(info) {
      return info.hasLoading;
    });
  };
  return ImReadyManager2;
}(component_esm_default);
var ImageLoader = function(_super) {
  __extends3(ImageLoader2, _super);
  function ImageLoader2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = ImageLoader2.prototype;
  __proto.checkElement = function() {
    var element = this.element;
    var src = element.getAttribute("src");
    if (element.complete) {
      if (src) {
        if (!element.naturalWidth) {
          this.onAlreadyError(element);
        }
        return false;
      } else {
        this.onAlreadyPreReady();
      }
    }
    this.addEvents();
    IS_IE && element.setAttribute("src", src);
    return true;
  };
  ImageLoader2.EVENTS = ["load", "error"];
  return ImageLoader2;
}(Loader);
var VideoLoader = function(_super) {
  __extends3(VideoLoader2, _super);
  function VideoLoader2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = VideoLoader2.prototype;
  __proto.checkElement = function() {
    var element = this.element;
    if (element.readyState >= 1) {
      return false;
    }
    if (element.error) {
      this.onAlreadyError(element);
      return false;
    }
    this.addEvents();
    return true;
  };
  VideoLoader2.EVENTS = ["loadedmetadata", "error"];
  return VideoLoader2;
}(Loader);
var ImReady = function(_super) {
  __extends3(ImReady2, _super);
  function ImReady2(options) {
    if (options === void 0) {
      options = {};
    }
    return _super.call(this, __assign({
      loaders: {
        img: ImageLoader,
        video: VideoLoader
      }
    }, options)) || this;
  }
  return ImReady2;
}(ImReadyManager);
var imready_esm_default = ImReady;

// node_modules/@egjs/grid/dist/grid.esm.js
var extendStatics4 = function(d, b) {
  extendStatics4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics4(d, b);
};
function __extends4(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
}
var DEFAULT_GRID_OPTIONS = {
  horizontal: false,
  useTransform: false,
  percentage: false,
  isEqualSize: false,
  isConstantSize: false,
  gap: 0,
  attributePrefix: "data-grid-",
  resizeDebounce: 100,
  maxResizeDebounce: 0,
  autoResize: true,
  preserveUIOnDestroy: false,
  defaultDirection: "end",
  externalContainerManager: null,
  externalItemRenderer: null,
  renderOnPropertyChange: true,
  useFit: true,
  outlineLength: 0,
  outlineSize: 0,
  useRoundedSize: true,
  useResizeObserver: false,
  observeChildren: false
};
var PROPERTY_TYPE;
(function(PROPERTY_TYPE2) {
  PROPERTY_TYPE2[PROPERTY_TYPE2["PROPERTY"] = 1] = "PROPERTY";
  PROPERTY_TYPE2[PROPERTY_TYPE2["RENDER_PROPERTY"] = 2] = "RENDER_PROPERTY";
})(PROPERTY_TYPE || (PROPERTY_TYPE = {}));
var MOUNT_STATE;
(function(MOUNT_STATE2) {
  MOUNT_STATE2[MOUNT_STATE2["UNCHECKED"] = 1] = "UNCHECKED";
  MOUNT_STATE2[MOUNT_STATE2["UNMOUNTED"] = 2] = "UNMOUNTED";
  MOUNT_STATE2[MOUNT_STATE2["MOUNTED"] = 3] = "MOUNTED";
})(MOUNT_STATE || (MOUNT_STATE = {}));
var UPDATE_STATE;
(function(UPDATE_STATE2) {
  UPDATE_STATE2[UPDATE_STATE2["NEED_UPDATE"] = 1] = "NEED_UPDATE";
  UPDATE_STATE2[UPDATE_STATE2["WAIT_LOADING"] = 2] = "WAIT_LOADING";
  UPDATE_STATE2[UPDATE_STATE2["UPDATED"] = 3] = "UPDATED";
})(UPDATE_STATE || (UPDATE_STATE = {}));
var GRID_PROPERTY_TYPES = {
  gap: PROPERTY_TYPE.RENDER_PROPERTY,
  defaultDirection: PROPERTY_TYPE.PROPERTY,
  renderOnPropertyChange: PROPERTY_TYPE.PROPERTY,
  preserveUIOnDestroy: PROPERTY_TYPE.PROPERTY,
  useFit: PROPERTY_TYPE.PROPERTY,
  outlineSize: PROPERTY_TYPE.RENDER_PROPERTY,
  outlineLength: PROPERTY_TYPE.RENDER_PROPERTY
};
var GRID_METHODS = ["syncElements", "updateItems", "getItems", "setItems", "renderItems", "getContainerInlineSize", "getContainerElement"];
var RECT_NAMES = {
  horizontal: {
    inlinePos: "top",
    contentPos: "left",
    inlineSize: "height",
    contentSize: "width"
  },
  vertical: {
    inlinePos: "left",
    contentPos: "top",
    inlineSize: "width",
    contentSize: "height"
  }
};
function getKeys(obj) {
  return Object.keys(obj);
}
function getUpdatedItems(items, entries) {
  var mountedItems = getMountedItems(items);
  return diff2(entries.map(function(entry) {
    return entry.target;
  }), mountedItems.map(function(item) {
    return item.element;
  })).maintained.filter(function(_a) {
    var prevIndex = _a[0], nextIndex = _a[1];
    var entrySize = entries[prevIndex].size;
    var item = items[nextIndex];
    return !item.inlineSize || !item.contentSize || entrySize.inlineSize !== item.computedInlineSize || entrySize.blockSize !== item.computedContentSize;
  }).map(function(_a) {
    var nextIndex = _a[1];
    return items[nextIndex];
  });
}
function getMountedItems(items) {
  return items.filter(function(item) {
    return item.element;
  });
}
function getMountedElements(items) {
  return getMountedItems(items).map(function(item) {
    return item.element;
  });
}
function isString2(val) {
  return typeof val === "string";
}
function isObject(val) {
  return typeof val === "object";
}
function isNumber(val) {
  return typeof val === "number";
}
function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function(all, letter) {
    return letter.toUpperCase();
  });
}
function sum(arr) {
  return arr.reduce(function(a, b) {
    return a + b;
  }, 0);
}
function getDataAttributes(element, attributePrefix) {
  var dataAttributes = {};
  var attributes = element.attributes;
  var length2 = attributes.length;
  for (var i = 0; i < length2; ++i) {
    var attribute = attributes[i];
    var name = attribute.name, value = attribute.value;
    if (name.indexOf(attributePrefix) === -1) {
      continue;
    }
    dataAttributes[camelize(name.replace(attributePrefix, ""))] = value;
  }
  return dataAttributes;
}
function GetterSetter(component) {
  var prototype = component.prototype, propertyTypes = component.propertyTypes;
  var _loop_1 = function(name2) {
    var shouldRender = propertyTypes[name2] === PROPERTY_TYPE.RENDER_PROPERTY;
    var descriptor = Object.getOwnPropertyDescriptor(prototype, name2) || {};
    var getter = descriptor.get || function get() {
      return this.options[name2];
    };
    var setter = descriptor.set || function set(value) {
      var options = this.options;
      var prevValue = options[name2];
      if (prevValue === value) {
        return;
      }
      options[name2] = value;
      if (shouldRender && options.renderOnPropertyChange) {
        this.scheduleRender();
      }
    };
    var attributes = {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    };
    Object.defineProperty(prototype, name2, attributes);
  };
  for (var name in propertyTypes) {
    _loop_1(name);
  }
}
function withMethods(methods) {
  return function(prototype, memberName) {
    methods.forEach(function(name) {
      if (name in prototype) {
        return;
      }
      prototype[name] = function() {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var result = (_a = this[memberName])[name].apply(_a, args);
        if (result === this[memberName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}
function range(length2) {
  var arr = [];
  for (var i = 0; i < length2; ++i) {
    arr.push(i);
  }
  return arr;
}
function getRangeCost(value, valueRange) {
  return Math.max(value - valueRange[1], valueRange[0] - value, 0) + 1;
}
function between(value, min, max) {
  return Math.min(max, Math.max(value, min));
}
function throttle(num, unit) {
  if (!unit) {
    return num;
  }
  var reverseUnit = 1 / unit;
  return Math.round(num / unit) / reverseUnit;
}
var withGridMethods = withMethods(GRID_METHODS);
var ResizeWatcher = function() {
  function ResizeWatcher2(container, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    this._resizeTimer = 0;
    this._maxResizeDebounceTimer = 0;
    this.rect = {
      width: 0,
      height: 0
    };
    this._updatedEntries = [];
    this._onWindowResize = function() {
      _this._scheduleResize([{
        target: _this.container
      }]);
    };
    this._onObserve = function(entries) {
      var options2 = _this._options;
      var container2 = _this.container;
      var containerRectBox = options2.rectBox;
      var childrenRectBox = options2.childrenRectBox;
      _this._scheduleResize(entries.map(function(entry) {
        var target = entry.target;
        var rectBox = target === container2 ? containerRectBox : childrenRectBox;
        var sizes = rectBox === "border-box" ? entry.borderBoxSize : entry.contentBoxSize;
        if (!sizes) {
          var contentRect = entry.contentRect;
          sizes = [{
            inlineSize: contentRect.width,
            blockSize: contentRect.height
          }];
        }
        return {
          // not array in old browser
          size: sizes[0] || sizes,
          target: entry.target
        };
      }));
    };
    this._scheduleResize = function(entries) {
      var _a = _this._options, resizeDebounce = _a.resizeDebounce, maxResizeDebounce = _a.maxResizeDebounce;
      var updatedEntries = _this._updatedEntries;
      updatedEntries.push.apply(updatedEntries, entries);
      _this._updatedEntries = updatedEntries.filter(function(entry, index) {
        return updatedEntries.lastIndexOf(entry) === index;
      });
      if (!_this._maxResizeDebounceTimer && maxResizeDebounce >= resizeDebounce) {
        _this._maxResizeDebounceTimer = window.setTimeout(_this._onResize, maxResizeDebounce);
      }
      if (_this._resizeTimer) {
        clearTimeout(_this._resizeTimer);
        _this._resizeTimer = 0;
      }
      _this._resizeTimer = window.setTimeout(_this._onResize, resizeDebounce);
    };
    this._onResize = function() {
      clearTimeout(_this._resizeTimer);
      clearTimeout(_this._maxResizeDebounceTimer);
      _this._maxResizeDebounceTimer = 0;
      _this._resizeTimer = 0;
      var updated = _this._updatedEntries;
      var container2 = _this.container;
      var containerEntry;
      var childEntries = updated.filter(function(entry) {
        if (entry.target === container2) {
          containerEntry = entry;
          return false;
        } else {
          return true;
        }
      });
      var isResizeChildren = childEntries.length > 0;
      var isResizeContainer = !!containerEntry;
      if (isResizeContainer) {
        var watchDirection = _this._options.watchDirection;
        var prevRect = _this.rect;
        var containerEntrySize = containerEntry.size;
        if (containerEntrySize) {
          _this.setRect({
            width: containerEntrySize.inlineSize,
            height: containerEntrySize.blockSize
          });
        } else {
          _this.resize();
        }
        var rect = _this.rect;
        var isWatchWidth = watchDirection === "box" || watchDirection === "width";
        var isWatchHeight = watchDirection === "box" || watchDirection === "height";
        isResizeContainer = !watchDirection || isWatchWidth && prevRect.width !== rect.width || isWatchHeight && prevRect.height !== rect.height;
      }
      _this._updatedEntries = [];
      if (isResizeContainer || isResizeChildren) {
        _this._emitter.trigger("resize", {
          isResizeContainer,
          childEntries
        });
      }
    };
    this._options = __assign2({
      resizeDebounce: 100,
      maxResizeDebounce: 0,
      useResizeObserver: false,
      useWindowResize: true,
      watchDirection: false,
      rectBox: "content-box",
      childrenRectBox: "border-box"
    }, options);
    this.container = isString2(container) ? document.querySelector(container) : container;
    this._init();
  }
  var __proto = ResizeWatcher2.prototype;
  __proto.getRect = function() {
    return this.rect;
  };
  __proto.setRect = function(rect) {
    this.rect = __assign2({}, rect);
  };
  __proto.isObserverEnabled = function() {
    return !!this._observer;
  };
  __proto.resize = function() {
    var container = this.container;
    this.setRect(this._options.rectBox === "border-box" ? {
      width: container.offsetWidth,
      height: container.offsetHeight
    } : {
      width: container.clientWidth,
      height: container.clientHeight
    });
  };
  __proto.observeChildren = function(children) {
    var observer = this._observer;
    if (!observer) {
      return;
    }
    var box = this._options.childrenRectBox;
    children.forEach(function(element) {
      if (element) {
        observer.observe(element, {
          box
        });
      }
    });
  };
  __proto.unobserveChildren = function(children) {
    var observer = this._observer;
    if (!observer) {
      return;
    }
    children.forEach(function(element) {
      if (element) {
        observer.unobserve(element);
      }
    });
  };
  __proto.listen = function(callback) {
    this._emitter.on("resize", callback);
    return this;
  };
  __proto.destroy = function() {
    var _a;
    (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    if (this._options.useWindowResize) {
      window.removeEventListener("resize", this._onWindowResize);
    }
  };
  __proto._init = function() {
    var container = this.container;
    var options = this._options;
    this._emitter = new component_esm_default();
    if (options.useResizeObserver && !!window.ResizeObserver) {
      this._observer = new window.ResizeObserver(this._onObserve);
      this._observer.observe(container, {
        box: options.rectBox
      });
    }
    if (options.useWindowResize) {
      window.addEventListener("resize", this._onWindowResize);
    }
    this.resize();
  };
  return ResizeWatcher2;
}();
var ContainerManager = function(_super) {
  __extends4(ContainerManager2, _super);
  function ContainerManager2(container, options) {
    var _this = _super.call(this) || this;
    _this.container = container;
    _this._onResize = function(e) {
      _this.trigger("resize", e);
    };
    _this.options = __assign2({
      horizontal: DEFAULT_GRID_OPTIONS.horizontal,
      autoResize: DEFAULT_GRID_OPTIONS.autoResize,
      resizeDebounce: DEFAULT_GRID_OPTIONS.resizeDebounce,
      maxResizeDebounce: DEFAULT_GRID_OPTIONS.maxResizeDebounce,
      useResizeObserver: DEFAULT_GRID_OPTIONS.useResizeObserver
    }, options);
    _this._init();
    return _this;
  }
  var __proto = ContainerManager2.prototype;
  __proto.resize = function() {
    var container = this.container;
    this.setRect({
      width: container.clientWidth,
      height: container.clientHeight
    });
  };
  __proto.isObserverEnabled = function() {
    return this._watcher.isObserverEnabled();
  };
  __proto.getRect = function() {
    return this._watcher.getRect();
  };
  __proto.observeChildren = function(children) {
    this._watcher.observeChildren(children);
  };
  __proto.unobserveChildren = function(children) {
    this._watcher.unobserveChildren(children);
  };
  __proto.setRect = function(rect) {
    this._watcher.setRect(rect);
  };
  __proto.getInlineSize = function() {
    return this.getRect()[this._names.inlineSize];
  };
  __proto.getContentSize = function() {
    return this.getRect()[this._names.contentSize];
  };
  __proto.getStatus = function() {
    return {
      rect: this._watcher.getRect()
    };
  };
  __proto.setStatus = function(status) {
    this.setRect(status.rect);
    this.setContentSize(this.getContentSize());
  };
  __proto.setContentSize = function(size) {
    var _a;
    var sizeName = this.options.horizontal ? "width" : "height";
    this.setRect(__assign2(__assign2({}, this.getRect()), (_a = {}, _a[sizeName] = size, _a)));
    this.container.style[sizeName] = size + "px";
  };
  __proto.destroy = function(options) {
    if (options === void 0) {
      options = {};
    }
    this._watcher.destroy();
    if (!options.preserveUI) {
      this.container.style.cssText = this.orgCSSText;
    }
  };
  __proto._init = function() {
    var container = this.container;
    var style = window.getComputedStyle(container);
    this.orgCSSText = container.style.cssText;
    if (style.position === "static") {
      container.style.position = "relative";
    }
    var options = this.options;
    this._watcher = new ResizeWatcher(container, {
      useWindowResize: options.autoResize,
      useResizeObserver: options.useResizeObserver,
      resizeDebounce: options.resizeDebounce,
      maxResizeDebounce: options.maxResizeDebounce,
      watchDirection: options.useResizeObserver ? this._names.inlineSize : false
    }).listen(this._onResize);
  };
  Object.defineProperty(__proto, "_names", {
    get: function() {
      return RECT_NAMES[this.options.horizontal ? "horizontal" : "vertical"];
    },
    enumerable: false,
    configurable: true
  });
  return ContainerManager2;
}(component_esm_default);
var ItemRenderer = function() {
  function ItemRenderer2(options) {
    this.initialRects = {};
    this.sizePercetage = false;
    this.posPercetage = false;
    this.options = __assign2({
      attributePrefix: DEFAULT_GRID_OPTIONS.attributePrefix,
      useTransform: DEFAULT_GRID_OPTIONS.useTransform,
      horizontal: DEFAULT_GRID_OPTIONS.horizontal,
      percentage: DEFAULT_GRID_OPTIONS.percentage,
      isEqualSize: DEFAULT_GRID_OPTIONS.isEqualSize,
      isConstantSize: DEFAULT_GRID_OPTIONS.isConstantSize,
      useRoundedSize: DEFAULT_GRID_OPTIONS.useRoundedSize
    }, options);
    this._init();
  }
  var __proto = ItemRenderer2.prototype;
  __proto.resize = function() {
    this.initialRects = {};
  };
  __proto.renderItems = function(items) {
    var _this = this;
    items.forEach(function(item) {
      _this._renderItem(item);
    });
  };
  __proto.getInlineSize = function() {
    return this.containerRect[this.options.horizontal ? "height" : "width"];
  };
  __proto.setContainerRect = function(rect) {
    this.containerRect = rect;
  };
  __proto.updateEqualSizeItems = function(items, totalItems) {
    var _this = this;
    this.updateItems(items);
    var hasSizeGroup = items.some(function(item) {
      return item.attributes.sizeGroup;
    });
    if (this.options.isEqualSize || hasSizeGroup) {
      var updatedItem = items.some(function(item) {
        return item.updateState === UPDATE_STATE.UPDATED;
      });
      if (updatedItem) {
        totalItems.forEach(function(item) {
          if (items.indexOf(item) === -1) {
            _this.updateItem(item, true);
          }
        });
      }
    }
  };
  __proto.updateItems = function(items) {
    var _this = this;
    items.forEach(function(item) {
      _this.updateItem(item);
    });
  };
  __proto.getStatus = function() {
    return {
      initialRects: this.initialRects
    };
  };
  __proto.setStatus = function(status) {
    this.initialRects = status.initialRects;
  };
  __proto._init = function() {
    var percentage = this.options.percentage;
    var sizePercentage = false;
    var posPercentage = false;
    if (percentage === true) {
      sizePercentage = true;
      posPercentage = true;
    } else if (percentage) {
      if (percentage.indexOf("position") > -1) {
        posPercentage = true;
      }
      if (percentage.indexOf("size") > -1) {
        sizePercentage = true;
      }
    }
    this.posPercetage = posPercentage;
    this.sizePercetage = sizePercentage;
  };
  __proto.updateItem = function(item, checkSizeGroup) {
    var _a;
    var _b = this.options, isEqualSize = _b.isEqualSize, isConstantSize = _b.isConstantSize, useRoundedSize = _b.useRoundedSize;
    var initialRects = this.initialRects;
    var orgRect = item.orgRect, element = item.element;
    var isLoading = item.updateState === UPDATE_STATE.WAIT_LOADING;
    var hasOrgSize = orgRect && orgRect.width && orgRect.height;
    var rect;
    var attributes = element ? getDataAttributes(element, this.options.attributePrefix) : item.attributes;
    var sizeGroup = (_a = attributes.sizeGroup) !== null && _a !== void 0 ? _a : "";
    var isNotEqualSize = attributes.notEqualSize;
    if (sizeGroup !== "" && initialRects[sizeGroup]) {
      rect = initialRects[sizeGroup];
    } else if (isEqualSize && !isNotEqualSize && !sizeGroup && initialRects[""]) {
      rect = initialRects[""];
    } else if (isConstantSize && hasOrgSize && !isLoading) {
      rect = orgRect;
    } else if (checkSizeGroup || !element) {
      return;
    } else {
      rect = {
        left: element.offsetLeft,
        top: element.offsetTop,
        width: 0,
        height: 0
      };
      if (useRoundedSize) {
        rect.width = element.offsetWidth;
        rect.height = element.offsetHeight;
      } else {
        var clientRect = element.getBoundingClientRect();
        rect.width = clientRect.width;
        rect.height = clientRect.height;
      }
    }
    item.attributes = attributes;
    item.shouldReupdate = false;
    if (!item.isFirstUpdate || !hasOrgSize) {
      item.orgRect = __assign2({}, rect);
    }
    item.rect = __assign2({}, rect);
    if (!checkSizeGroup) {
      if (item.element) {
        item.mountState = MOUNT_STATE.MOUNTED;
      }
      if (item.updateState === UPDATE_STATE.NEED_UPDATE) {
        item.updateState = UPDATE_STATE.UPDATED;
        item.isFirstUpdate = true;
      }
      if (!isLoading && !isNotEqualSize && !initialRects[sizeGroup]) {
        initialRects[sizeGroup] = __assign2({}, rect);
      }
    }
    return rect;
  };
  __proto._renderItem = function(item) {
    var element = item.element;
    var cssRect = item.cssRect;
    if (!element || !cssRect) {
      return;
    }
    var _a = this.options, horizontal = _a.horizontal, useTransform = _a.useTransform;
    var posPercentage = this.posPercetage;
    var sizePercentage = this.sizePercetage;
    var cssTexts = ["position: absolute;"];
    var _b = RECT_NAMES[horizontal ? "horizontal" : "vertical"], sizeName = _b.inlineSize, posName = _b.inlinePos;
    var inlineSize = this.getInlineSize();
    var keys = getKeys(cssRect);
    var hasRectProperties = keys.length > 0;
    if (useTransform) {
      keys = keys.filter(function(key) {
        return key !== "top" && key !== "left";
      });
      cssTexts.push("transform: " + ("translate(" + (cssRect.left || 0) + "px, " + (cssRect.top || 0) + "px);"));
    }
    cssTexts.push.apply(cssTexts, keys.map(function(name) {
      var value = cssRect[name];
      if (name === sizeName && sizePercentage || name === posName && posPercentage) {
        return name + ": " + value / inlineSize * 100 + "%;";
      }
      return name + ": " + value + "px;";
    }));
    if (hasRectProperties) {
      element.style.cssText += cssTexts.join("");
    }
  };
  return ItemRenderer2;
}();
var GridItem = function() {
  function GridItem2(horizontal, itemStatus) {
    if (itemStatus === void 0) {
      itemStatus = {};
    }
    var _a;
    this.horizontal = horizontal;
    this.isUpdating = false;
    this.shouldReupdate = false;
    this.hasTransition = false;
    this.transitionDuration = "";
    this.isRestoreOrgCSSText = true;
    var element = itemStatus.element;
    var status = __assign2({
      key: "",
      index: 0,
      orgRect: {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      },
      rect: {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      },
      cssRect: {},
      attributes: {},
      data: {},
      isFirstUpdate: false,
      mountState: MOUNT_STATE.UNCHECKED,
      updateState: UPDATE_STATE.NEED_UPDATE,
      element: element || null,
      orgCSSText: (_a = element === null || element === void 0 ? void 0 : element.style.cssText) !== null && _a !== void 0 ? _a : "",
      gridData: {}
    }, itemStatus);
    for (var name in status) {
      this[name] = status[name];
    }
  }
  var __proto = GridItem2.prototype;
  Object.defineProperty(__proto, "orgInlineSize", {
    /**
     * The size in inline direction before first rendering. "width" if horizontal is false, "height" otherwise.
     * @ko 첫 렌더링 되기 전의 inline 방향의 사이즈. horizontal이 false면 "width", 아니면 "height".
     * @member Grid.GridItem#orgInlineSize
     */
    get: function() {
      var name = this._names.inlineSize;
      return this.orgRect[name] || this.rect[name];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "orgContentSize", {
    /**
     * The size in content direction before first rendering. "height" if horizontal is false, "width" otherwise.
     * @ko 첫 렌더링 되기 전의 content 방향의 사이즈. horizontal이 false면 "height", 아니면 "width".
     * @member Grid.GridItem#orgContentSize
     */
    get: function() {
      var name = this._names.contentSize;
      return this.orgRect[name] || this.rect[name];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "inlineSize", {
    /**
     * The size in inline direction. "width" if horizontal is false, "height" otherwise.
     * @ko inline 방향의 사이즈. horizontal이 false면 "width", 아니면 "height".
     * @member Grid.GridItem#inlineSize
     */
    get: function() {
      return this.rect[this._names.inlineSize];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "contentSize", {
    /**
     * The size in content direction. "height" if horizontal is false, "width" otherwise.
     * @ko content 방향의 사이즈. horizontal이 false면 "height", 아니면 "width".
     * @member Grid.GridItem#contentSize
     */
    get: function() {
      return this.rect[this._names.contentSize];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cssInlineSize", {
    /**
     * The CSS size in inline direction applied to the Grid. "width" if horizontal is false, "height" otherwise.
     * @ko Grid에 적용된 inline 방향의 CSS 사이즈. horizontal이 false면 "width", 아니면 "height".
     * @member Grid.GridItem#cssInlineSize
     */
    get: function() {
      return this.cssRect[this._names.inlineSize];
    },
    set: function(inlineSize) {
      this.cssRect[this._names.inlineSize] = inlineSize;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cssContentSize", {
    /**
     * The CSS size in content direction applied to the Grid. "height" if horizontal is false, "width" otherwise.
     * @ko Grid에 적용된 content 방향의 CSS 사이즈. horizontal이 false면 "height", 아니면 "width".
     * @member Grid.GridItem#cssContentSize
     */
    get: function() {
      return this.cssRect[this._names.contentSize];
    },
    set: function(contentSize) {
      this.cssRect[this._names.contentSize] = contentSize;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cssInlinePos", {
    /**
     * The CSS pos in inline direction applied to the Grid. "left" if horizontal is false, "top" otherwise.
     * @ko Grid에 적용된 inline 방향의 CSS 포지션. horizontal이 false면 "left", 아니면 "top".
     * @member Grid.GridItem#cssInlinePos
     */
    get: function() {
      return this.cssRect[this._names.inlinePos];
    },
    set: function(inlinePos) {
      this.cssRect[this._names.inlinePos] = inlinePos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cssContentPos", {
    /**
     * The CSS pos in content direction applied to the Grid. "top" if horizontal is false, "left" otherwise.
     * @ko Grid에 적용된 content 방향의 CSS 포지션. horizontal이 false면 "top", 아니면 "left".
     * @member Grid.GridItem#cssContentPos
     */
    get: function() {
      return this.cssRect[this._names.contentPos];
    },
    set: function(contentPos) {
      this.cssRect[this._names.contentPos] = contentPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "computedInlineSize", {
    /**
     * Calculated size in the direction of the inline applied to the grid. "width" if horizontal is false, "height" otherwise.
     * @ko Grid에 적용된 inline 방향의 계산된 사이즈. horizontal이 false면 "width", 아니면 "height".
     * @member Grid.GridItem#computedInlineSize
     */
    get: function() {
      var name = this._names.inlineSize;
      return this.cssRect[name] || this.rect[name] || this.orgRect[name];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "computedContentSize", {
    /**
     * Calculated size in the direction of the content applied to the grid. "height" if horizontal is false, "width" otherwise.
     * @ko Grid에 적용된 content 방향의 계산된 사이즈. horizontal이 false면 "height", 아니면 "width".
     * @member Grid.GridItem#computedContentSize
     */
    get: function() {
      var name = this._names.contentSize;
      return this.cssRect[name] || this.rect[name] || this.orgRect[name];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "computedInlinePos", {
    /**
     * Calculated position in the direction of the inline applied to the grid. "left" if horizontal is false, "top" otherwise.
     * @ko Grid에 적용된 content 방향의 계산된 포지션. horizontal이 false면 "left", 아니면 "top".
     * @member Grid.GridItem#computedInlinePos
     */
    get: function() {
      var _a;
      var name = this._names.inlinePos;
      return (_a = this.cssRect[name]) !== null && _a !== void 0 ? _a : this.rect[name];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "computedContentPos", {
    /**
     * Calculated position in the direction of the content applied to the grid. "top" if horizontal is false, "left" otherwise.
     * @ko Grid에 적용된 content 방향의 계산된 포지션. horizontal이 false면 "top", 아니면 "left".
     * @member Grid.GridItem#computedContentPos
     */
    get: function() {
      var _a;
      var name = this._names.contentPos;
      return (_a = this.cssRect[name]) !== null && _a !== void 0 ? _a : this.rect[name];
    },
    enumerable: false,
    configurable: true
  });
  __proto.setCSSGridRect = function(gridRect) {
    var names = RECT_NAMES[this.horizontal ? "horizontal" : "vertical"];
    var rect = {};
    for (var name in gridRect) {
      rect[names[name]] = gridRect[name];
    }
    this.cssRect = rect;
  };
  __proto.getStatus = function() {
    return {
      index: this.index,
      mountState: this.mountState,
      updateState: this.updateState,
      attributes: this.attributes,
      orgCSSText: this.orgCSSText,
      isFirstUpdate: this.isFirstUpdate,
      element: null,
      key: this.key,
      orgRect: this.orgRect,
      rect: this.rect,
      cssRect: this.cssRect,
      gridData: this.gridData,
      data: this.data
    };
  };
  __proto.getMinimizedStatus = function() {
    var status = {
      orgRect: this.orgRect,
      rect: this.rect,
      cssRect: this.cssRect,
      attributes: this.attributes,
      gridData: this.gridData
    };
    var _a = this, key = _a.key, mountState = _a.mountState, updateState = _a.updateState, isFirstUpdate = _a.isFirstUpdate, orgCSSText = _a.orgCSSText;
    if (typeof key !== "undefined") {
      status.key = key;
    }
    if (mountState !== MOUNT_STATE.UNCHECKED) {
      status.mountState = mountState;
    }
    if (updateState !== UPDATE_STATE.NEED_UPDATE) {
      status.updateState = updateState;
    }
    if (isFirstUpdate) {
      status.isFirstUpdate = true;
    }
    if (orgCSSText) {
      status.orgCSSText = orgCSSText;
    }
    return status;
  };
  Object.defineProperty(__proto, "_names", {
    get: function() {
      return this.horizontal ? RECT_NAMES.horizontal : RECT_NAMES.vertical;
    },
    enumerable: false,
    configurable: true
  });
  return GridItem2;
}();
var Grid = function(_super) {
  __extends4(Grid2, _super);
  function Grid2(containerElement, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.items = [];
    _this.outlines = {
      start: [],
      end: []
    };
    _this._renderTimer = 0;
    _this._onResize = function(e) {
      if (e.isResizeContainer) {
        _this._renderItems({
          useResize: true
        }, true);
      } else {
        var updatedItems = getUpdatedItems(_this.items, e.childEntries);
        if (updatedItems.length > 0) {
          _this.updateItems(updatedItems);
        }
      }
    };
    _this.options = __assign2(__assign2({}, _this.constructor.defaultOptions), options);
    _this.containerElement = isString2(containerElement) ? document.querySelector(containerElement) : containerElement;
    var _a = _this.options, isEqualSize = _a.isEqualSize, isConstantSize = _a.isConstantSize, useTransform = _a.useTransform, horizontal = _a.horizontal, percentage = _a.percentage, externalContainerManager = _a.externalContainerManager, externalItemRenderer = _a.externalItemRenderer, resizeDebounce = _a.resizeDebounce, maxResizeDebounce = _a.maxResizeDebounce, autoResize = _a.autoResize, useRoundedSize = _a.useRoundedSize, useResizeObserver = _a.useResizeObserver;
    _this.containerManager = externalContainerManager || new ContainerManager(_this.containerElement, {
      horizontal,
      resizeDebounce,
      maxResizeDebounce,
      autoResize,
      useResizeObserver
    }).on("resize", _this._onResize);
    _this.itemRenderer = externalItemRenderer || new ItemRenderer({
      useTransform,
      isEqualSize,
      isConstantSize,
      percentage,
      useRoundedSize
    });
    _this._init();
    return _this;
  }
  var __proto = Grid2.prototype;
  Grid_1 = Grid2;
  __proto.getContainerElement = function() {
    return this.containerElement;
  };
  __proto.getItems = function() {
    return this.items;
  };
  __proto.getChildren = function() {
    return [].slice.call(this.containerElement.children);
  };
  __proto.setItems = function(items) {
    items.forEach(function(item, i) {
      item.index = i;
    });
    var options = this.options;
    if (options.useResizeObserver && options.observeChildren) {
      var containerManager = this.containerManager;
      containerManager.unobserveChildren(getMountedElements(this.items));
      containerManager.observeChildren(getMountedElements(items));
    }
    this.items = items;
    return this;
  };
  __proto.getContainerInlineSize = function() {
    return this.containerManager.getInlineSize();
  };
  __proto.getOutlines = function() {
    return this.outlines;
  };
  __proto.setOutlines = function(outlines) {
    this.outlines = outlines;
    return this;
  };
  __proto.syncElements = function(options) {
    if (options === void 0) {
      options = {};
    }
    var items = this.items;
    var horizontal = this.options.horizontal;
    var elements2 = this.getChildren();
    var _a = diff2(this.items.map(function(item) {
      return item.element;
    }), elements2), added = _a.added, maintained = _a.maintained, changed = _a.changed, removed = _a.removed;
    var nextItems = [];
    maintained.forEach(function(_a2) {
      var beforeIndex = _a2[0], afterIndex = _a2[1];
      nextItems[afterIndex] = items[beforeIndex];
    });
    added.forEach(function(index) {
      nextItems[index] = new GridItem(horizontal, {
        element: elements2[index]
      });
    });
    this.setItems(nextItems);
    if (added.length || removed.length || changed.length) {
      this.renderItems(options);
    }
    return this;
  };
  __proto.updateItems = function(items, options) {
    if (items === void 0) {
      items = this.items;
    }
    if (options === void 0) {
      options = {};
    }
    var useOrgResize = options.useOrgResize;
    items.forEach(function(item) {
      if (useOrgResize) {
        var orgRect = item.orgRect;
        orgRect.width = 0;
        orgRect.height = 0;
      }
      item.updateState = UPDATE_STATE.NEED_UPDATE;
    });
    this.checkReady(options);
    return this;
  };
  __proto.renderItems = function(options) {
    if (options === void 0) {
      options = {};
    }
    this._renderItems(options);
    return this;
  };
  __proto.getStatus = function(minimize) {
    return {
      outlines: this.outlines,
      items: this.items.map(function(item) {
        return minimize ? item.getMinimizedStatus() : item.getStatus();
      }),
      containerManager: this.containerManager.getStatus(),
      itemRenderer: this.itemRenderer.getStatus()
    };
  };
  __proto.setStatus = function(status) {
    var _this = this;
    var horizontal = this.options.horizontal;
    var containerManager = this.containerManager;
    var prevInlineSize = containerManager.getInlineSize();
    var children = this.getChildren();
    this.itemRenderer.setStatus(status.itemRenderer);
    containerManager.setStatus(status.containerManager);
    this.outlines = status.outlines;
    this.items = status.items.map(function(item, i) {
      return new GridItem(horizontal, __assign2(__assign2({}, item), {
        element: children[i]
      }));
    });
    this.itemRenderer.renderItems(this.items);
    if (prevInlineSize !== containerManager.getInlineSize()) {
      this.renderItems({
        useResize: true
      });
    } else {
      window.setTimeout(function() {
        _this._renderComplete({
          direction: _this.defaultDirection,
          mounted: _this.items,
          updated: [],
          isResize: false
        });
      });
    }
    return this;
  };
  __proto.getComputedOutlineSize = function(items) {
    if (items === void 0) {
      items = this.items;
    }
    return this.options.outlineSize || this.getContainerInlineSize();
  };
  __proto.getComputedOutlineLength = function(items) {
    if (items === void 0) {
      items = this.items;
    }
    return this.options.outlineLength || 1;
  };
  __proto.destroy = function(options) {
    var _a;
    if (options === void 0) {
      options = {};
    }
    var _b = options.preserveUI, preserveUI = _b === void 0 ? this.options.preserveUIOnDestroy : _b;
    this.containerManager.destroy({
      preserveUI
    });
    if (!preserveUI) {
      this.items.forEach(function(_a2) {
        var element = _a2.element, orgCSSText = _a2.orgCSSText;
        if (element) {
          element.style.cssText = orgCSSText;
        }
      });
    }
    (_a = this._im) === null || _a === void 0 ? void 0 : _a.destroy();
  };
  __proto.getInlineGap = function() {
    return this._getDirectionalGap("inline");
  };
  __proto.getContentGap = function() {
    return this._getDirectionalGap("content");
  };
  __proto.checkReady = function(options) {
    var _this = this;
    var _a;
    if (options === void 0) {
      options = {};
    }
    var items = this.items;
    var updated = items.filter(function(item) {
      var _a2;
      return ((_a2 = item.element) === null || _a2 === void 0 ? void 0 : _a2.parentNode) && item.updateState !== UPDATE_STATE.UPDATED;
    });
    var mounted = items.filter(function(item) {
      var _a2;
      return ((_a2 = item.element) === null || _a2 === void 0 ? void 0 : _a2.parentNode) && item.mountState !== MOUNT_STATE.MOUNTED;
    });
    var moreUpdated = [];
    mounted.filter(function(item) {
      if (item.hasTransition) {
        return true;
      } else {
        var element = item.element;
        var transitionDuration = parseFloat(getComputedStyle(element).transitionDuration);
        if (transitionDuration > 0) {
          item.hasTransition = true;
          item.transitionDuration = element.style.transitionDuration;
          return true;
        }
      }
      return false;
    }).forEach(function(item) {
      item.element.style.transitionDuration = "0s";
    });
    (_a = this._im) === null || _a === void 0 ? void 0 : _a.destroy();
    this._im = new imready_esm_default({
      prefix: this.options.attributePrefix
    }).on("preReadyElement", function(e) {
      updated[e.index].updateState = UPDATE_STATE.WAIT_LOADING;
    }).on("preReady", function() {
      updated.forEach(function(item) {
        var hasOrgSize = item.orgRect.width && item.orgRect.height;
        var hasCSSSize = item.cssRect.width || item.cssRect.height;
        if (!hasOrgSize && hasCSSSize) {
          item.element.style.cssText = item.orgCSSText;
        }
      });
      _this._updateItems(updated);
      _this.readyItems(mounted, updated, options);
    }).on("readyElement", function(e) {
      var item = updated[e.index];
      item.updateState = UPDATE_STATE.NEED_UPDATE;
      if (e.isPreReadyOver) {
        if (item.isRestoreOrgCSSText) {
          item.element.style.cssText = item.orgCSSText;
        }
        _this._updateItems([item]);
        _this.readyItems([], [item], options);
      }
    }).on("error", function(e) {
      var item = updated[e.index];
      _this.trigger("contentError", {
        element: e.element,
        target: e.target,
        item,
        update: function() {
          moreUpdated.push(item);
        }
      });
    }).on("ready", function() {
      if (moreUpdated.length) {
        _this.updateItems(moreUpdated);
      }
    }).check(updated.map(function(item) {
      return item.element;
    }));
  };
  __proto.scheduleRender = function() {
    var _this = this;
    this._clearRenderTimer();
    this._renderTimer = window.setTimeout(function() {
      _this.renderItems();
    });
  };
  __proto.fitOutlines = function(useFit) {
    if (useFit === void 0) {
      useFit = this.useFit;
    }
    var outlines = this.outlines;
    var startOutline = outlines.start;
    var endOutline = outlines.end;
    var outlineOffset = startOutline.length ? Math.min.apply(Math, startOutline) : 0;
    if (!useFit && outlineOffset > 0) {
      return;
    }
    outlines.start = startOutline.map(function(point) {
      return point - outlineOffset;
    });
    outlines.end = endOutline.map(function(point) {
      return point - outlineOffset;
    });
    this.items.forEach(function(item) {
      var contentPos = item.cssContentPos;
      if (!isNumber(contentPos)) {
        return;
      }
      item.cssContentPos = contentPos - outlineOffset;
    });
  };
  __proto.readyItems = function(mounted, updated, options) {
    var prevOutlines = this.outlines;
    var direction = options.direction || this.options.defaultDirection;
    var prevOutline = options.outline || prevOutlines[direction === "end" ? "start" : "end"];
    var items = this.items;
    var nextOutlines = {
      start: __spreadArray([], prevOutline),
      end: __spreadArray([], prevOutline)
    };
    mounted.forEach(function(item) {
      item.mountState = MOUNT_STATE.MOUNTED;
    });
    updated.forEach(function(item) {
      item.isUpdating = true;
    });
    if (items.length) {
      nextOutlines = this.applyGrid(this.items, direction, prevOutline);
    }
    updated.forEach(function(item) {
      item.isUpdating = false;
    });
    this.setOutlines(nextOutlines);
    this.fitOutlines();
    this.itemRenderer.renderItems(this.items);
    this._refreshContainerContentSize();
    var transitionMounted = mounted.filter(function(item) {
      return item.hasTransition;
    });
    if (transitionMounted.length) {
      this.containerManager.resize();
      transitionMounted.forEach(function(item) {
        var element = item.element;
        element.style.transitionDuration = item.transitionDuration;
      });
    }
    this._renderComplete({
      direction,
      mounted,
      updated,
      isResize: !!options.useResize
    });
    var shouldReupdateItems = updated.filter(function(item) {
      return item.shouldReupdate;
    });
    if (shouldReupdateItems.length) {
      this.updateItems(shouldReupdateItems);
    }
  };
  __proto._isObserverEnabled = function() {
    return this.containerManager.isObserverEnabled();
  };
  __proto._updateItems = function(items) {
    this.itemRenderer.updateEqualSizeItems(items, this.getItems());
  };
  __proto._getDirectionalGap = function(direction) {
    var _a;
    var horizontal = this.options.horizontal;
    var gap = this.options.gap;
    if (typeof gap === "number") return gap;
    var isVerticalGap = horizontal && direction === "inline" || !horizontal && direction === "content";
    return (_a = isVerticalGap ? gap.vertical : gap.horizontal) !== null && _a !== void 0 ? _a : DEFAULT_GRID_OPTIONS["gap"];
  };
  __proto._renderComplete = function(e) {
    this.trigger("renderComplete", e);
  };
  __proto._clearRenderTimer = function() {
    clearTimeout(this._renderTimer);
    this._renderTimer = 0;
  };
  __proto._refreshContainerContentSize = function() {
    var _a = this.outlines, startOutline = _a.start, endOutline = _a.end;
    var contentGap = this.getContentGap();
    var endPoint = endOutline.length ? Math.max.apply(Math, endOutline) : 0;
    var startPoint = startOutline.length ? Math.max.apply(Math, startOutline) : 0;
    var contentSize = Math.max(startPoint, endPoint - contentGap);
    this.containerManager.setContentSize(contentSize);
  };
  __proto._resizeContainer = function() {
    this.containerManager.resize();
    this.itemRenderer.setContainerRect(this.containerManager.getRect());
  };
  __proto._init = function() {
    this._resizeContainer();
  };
  __proto._renderItems = function(options, isTrusted) {
    if (options === void 0) {
      options = {};
    }
    this._clearRenderTimer();
    var isResize = options.useResize || options.useOrgResize;
    if (isResize && !isTrusted) {
      this._resizeContainer();
      this.itemRenderer.resize();
    }
    if (!this.getItems().length && this.getChildren().length) {
      this.syncElements(options);
    } else if (isResize) {
      this.updateItems(this.items, options);
    } else {
      this.checkReady(options);
    }
  };
  var Grid_1;
  Grid2.defaultOptions = DEFAULT_GRID_OPTIONS;
  Grid2.propertyTypes = GRID_PROPERTY_TYPES;
  Grid2 = Grid_1 = __decorate([GetterSetter], Grid2);
  return Grid2;
}(component_esm_default);
function getColumnPoint(outline, columnIndex, columnCount, pointCaculationName) {
  return Math[pointCaculationName].apply(Math, outline.slice(columnIndex, columnIndex + columnCount));
}
function getColumnIndex(outline, columnCount, nearestCalculationName, startPos) {
  var length2 = outline.length - columnCount + 1;
  var pointCaculationName = nearestCalculationName === "max" ? "min" : "max";
  var indexCaculationName = nearestCalculationName === "max" ? "lastIndexOf" : "indexOf";
  var points = range(length2).map(function(index) {
    var point = getColumnPoint(outline, index, columnCount, pointCaculationName);
    return Math[pointCaculationName](startPos, point);
  });
  return points[indexCaculationName](Math[nearestCalculationName].apply(Math, points));
}
var MasonryGrid = function(_super) {
  __extends4(MasonryGrid2, _super);
  function MasonryGrid2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = MasonryGrid2.prototype;
  __proto.applyGrid = function(items, direction, outline) {
    items.forEach(function(item) {
      item.isRestoreOrgCSSText = false;
    });
    var columnSize = this.getComputedOutlineSize(items);
    var column = this.getComputedOutlineLength(items);
    var _a = this.options, align = _a.align, observeChildren = _a.observeChildren, columnSizeRatio = _a.columnSizeRatio, contentAlign = _a.contentAlign;
    var inlineGap = this.getContentGap();
    var contentGap = this.getContentGap();
    var outlineLength = outline.length;
    var itemsLength = items.length;
    var alignPoses = this._getAlignPoses(column, columnSize);
    var isEndDirection = direction === "end";
    var nearestCalculationName = isEndDirection ? "min" : "max";
    var pointCalculationName = isEndDirection ? "max" : "min";
    var startOutline = [0];
    if (outlineLength === column) {
      startOutline = outline.slice();
    } else {
      var point_1 = outlineLength ? Math[pointCalculationName].apply(Math, outline) : 0;
      startOutline = range(column).map(function() {
        return point_1;
      });
    }
    var endOutline = startOutline.slice();
    var columnDist = column > 1 ? alignPoses[1] - alignPoses[0] : 0;
    var isStretch = align === "stretch";
    var isStartContentAlign = isEndDirection && contentAlign === "start";
    var startPos = isEndDirection ? -Infinity : Infinity;
    if (isStartContentAlign) {
      startPos = Math.min.apply(Math, endOutline);
    }
    var _loop_1 = function(i2) {
      var item = items[isEndDirection ? i2 : itemsLength - 1 - i2];
      var columnAttribute = parseInt(item.attributes.column || "1", 10);
      var maxColumnAttribute = parseInt(item.attributes.maxColumn || "1", 10);
      var contentSize = item.contentSize;
      var columnCount = Math.min(column, columnAttribute || Math.max(1, Math.ceil((item.inlineSize + inlineGap) / columnDist)));
      var maxColumnCount = Math.min(column, Math.max(columnCount, maxColumnAttribute));
      var columnIndex = getColumnIndex(endOutline, columnCount, nearestCalculationName, startPos);
      var contentPos = getColumnPoint(endOutline, columnIndex, columnCount, pointCalculationName);
      if (isStartContentAlign && startPos !== contentPos) {
        startPos = Math.max.apply(Math, endOutline);
        endOutline = endOutline.map(function() {
          return startPos;
        });
        contentPos = startPos;
        columnIndex = 0;
      }
      while (columnCount < maxColumnCount) {
        var nextEndColumnIndex = columnIndex + columnCount;
        var nextColumnIndex = columnIndex - 1;
        if (isEndDirection && (nextEndColumnIndex >= column || endOutline[nextEndColumnIndex] > contentPos)) {
          break;
        }
        if (!isEndDirection && (nextColumnIndex < 0 || endOutline[nextColumnIndex] < contentPos)) {
          break;
        }
        if (!isEndDirection) {
          --columnIndex;
        }
        ++columnCount;
      }
      columnIndex = Math.max(0, columnIndex);
      columnCount = Math.min(column - columnIndex, columnCount);
      if (columnAttribute > 0 && columnCount > 1 || isStretch) {
        var nextInlineSize = (columnCount - 1) * columnDist + columnSize;
        if ((!this_1._isObserverEnabled() || !observeChildren) && item.cssInlineSize !== nextInlineSize) {
          item.shouldReupdate = true;
        }
        item.cssInlineSize = nextInlineSize;
      }
      if (columnSizeRatio > 0) {
        contentSize = item.computedInlineSize / columnSizeRatio;
        item.cssContentSize = contentSize;
      }
      var inlinePos = alignPoses[columnIndex];
      contentPos = isEndDirection ? contentPos : contentPos - contentGap - contentSize;
      item.cssInlinePos = inlinePos;
      item.cssContentPos = contentPos;
      var nextOutlinePoint = isEndDirection ? contentPos + contentSize + contentGap : contentPos;
      range(columnCount).forEach(function(indexOffset) {
        endOutline[columnIndex + indexOffset] = nextOutlinePoint;
      });
    };
    var this_1 = this;
    for (var i = 0; i < itemsLength; ++i) {
      _loop_1(i);
    }
    if (isStartContentAlign && startPos !== Math.min.apply(Math, endOutline)) {
      startPos = Math.max.apply(Math, endOutline);
      endOutline = endOutline.map(function() {
        return startPos;
      });
    }
    return {
      start: isEndDirection ? startOutline : endOutline,
      end: isEndDirection ? endOutline : startOutline
    };
  };
  __proto.getComputedOutlineSize = function(items) {
    if (items === void 0) {
      items = this.items;
    }
    var align = this.options.align;
    var inlineGap = this.getInlineGap();
    var containerInlineSize = this.getContainerInlineSize();
    var columnSizeOption = this.columnSize || this.outlineSize;
    var columnOption = this.column || this.outlineLength;
    var column = columnOption || 1;
    var columnSize = 0;
    if (align === "stretch") {
      if (!columnOption) {
        var maxStretchColumnSize = this.maxStretchColumnSize || Infinity;
        column = Math.max(1, Math.ceil((containerInlineSize + inlineGap) / (maxStretchColumnSize + inlineGap)));
      }
      columnSize = (containerInlineSize + inlineGap) / (column || 1) - inlineGap;
    } else if (columnSizeOption) {
      columnSize = columnSizeOption;
    } else if (items.length) {
      var checkedItem = items[0];
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var item = items_1[_i];
        var attributes = item.attributes;
        var columnAttribute = parseInt(attributes.column || "1", 10);
        var maxColumnAttribute = parseInt(attributes.maxColumn || "1", 10);
        if (item.updateState !== UPDATE_STATE.UPDATED || !item.inlineSize || columnAttribute !== 1 || maxColumnAttribute !== 1) {
          continue;
        }
        checkedItem = item;
        break;
      }
      var inlineSize = checkedItem.inlineSize || 0;
      columnSize = inlineSize;
    } else {
      columnSize = containerInlineSize;
    }
    return columnSize || 0;
  };
  __proto.getComputedOutlineLength = function(items) {
    if (items === void 0) {
      items = this.items;
    }
    var inlineGap = this.getInlineGap();
    var columnOption = this.column || this.outlineLength;
    var columnCalculationThreshold = this.columnCalculationThreshold;
    var column = 1;
    if (columnOption) {
      column = columnOption;
    } else {
      var columnSize = this.getComputedOutlineSize(items);
      column = Math.min(items.length, Math.max(1, Math.floor((this.getContainerInlineSize() + inlineGap) / (columnSize - columnCalculationThreshold + inlineGap))));
    }
    return column;
  };
  __proto._getAlignPoses = function(column, columnSize) {
    var align = this.options.align;
    var inlineGap = this.getInlineGap();
    var containerSize = this.getContainerInlineSize();
    var indexes = range(column);
    var offset = 0;
    var dist = 0;
    if (align === "justify" || align === "stretch") {
      var countDist = column - 1;
      dist = countDist ? Math.max((containerSize - columnSize) / countDist, columnSize + inlineGap) : 0;
      offset = Math.min(0, containerSize / 2 - (countDist * dist + columnSize) / 2);
    } else {
      dist = columnSize + inlineGap;
      var totalColumnSize = (column - 1) * dist + columnSize;
      if (align === "center") {
        offset = (containerSize - totalColumnSize) / 2;
      } else if (align === "end") {
        offset = containerSize - totalColumnSize;
      }
    }
    return indexes.map(function(i) {
      return offset + i * dist;
    });
  };
  MasonryGrid2.propertyTypes = __assign2(__assign2({}, Grid.propertyTypes), {
    column: PROPERTY_TYPE.RENDER_PROPERTY,
    columnSize: PROPERTY_TYPE.RENDER_PROPERTY,
    columnSizeRatio: PROPERTY_TYPE.RENDER_PROPERTY,
    align: PROPERTY_TYPE.RENDER_PROPERTY,
    columnCalculationThreshold: PROPERTY_TYPE.RENDER_PROPERTY,
    maxStretchColumnSize: PROPERTY_TYPE.RENDER_PROPERTY,
    contentAlign: PROPERTY_TYPE.RENDER_PROPERTY
  });
  MasonryGrid2.defaultOptions = __assign2(__assign2({}, Grid.defaultOptions), {
    align: "justify",
    column: 0,
    columnSize: 0,
    columnSizeRatio: 0,
    columnCalculationThreshold: 0.5,
    maxStretchColumnSize: Infinity,
    contentAlign: "masonry"
  });
  MasonryGrid2 = __decorate([GetterSetter], MasonryGrid2);
  return MasonryGrid2;
}(Grid);
function single_source_shortest_paths(graph, s, d) {
  var predecessors = {};
  var costs = {};
  costs[s] = 0;
  var open = new BinaryHeap(function(x) {
    return x.cost;
  });
  open.push({
    value: s,
    cost: 0
  });
  var closest;
  var u;
  var cost_of_s_to_u;
  var adjacent_nodes;
  var cost_of_e;
  var cost_of_s_to_u_plus_cost_of_e;
  var cost_of_s_to_v;
  var first_visit;
  while (open.size()) {
    closest = open.pop();
    u = closest.value;
    cost_of_s_to_u = closest.cost;
    adjacent_nodes = graph(u) || {};
    for (var v in adjacent_nodes) {
      cost_of_e = adjacent_nodes[v];
      cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
      cost_of_s_to_v = costs[v];
      first_visit = typeof costs[v] === "undefined";
      if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
        costs[v] = cost_of_s_to_u_plus_cost_of_e;
        open.push({
          value: v,
          cost: cost_of_s_to_u_plus_cost_of_e
        });
        predecessors[v] = u;
      }
    }
  }
  if (typeof costs[d] === "undefined") {
    var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
    throw new Error(msg);
  }
  return predecessors;
}
function extract_shortest_path_from_predecessor_list(predecessors, d) {
  var nodes = [];
  var u = d;
  while (u) {
    nodes.push(u);
    u = predecessors[u];
  }
  nodes.reverse();
  return nodes;
}
function find_path(graph, s, d) {
  var predecessors = single_source_shortest_paths(graph, s, d);
  return extract_shortest_path_from_predecessor_list(predecessors, d);
}
var BinaryHeap = function() {
  function BinaryHeap2(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }
  var __proto = BinaryHeap2.prototype;
  __proto.push = function(element) {
    this.content.push(element);
    this.bubbleUp(this.content.length - 1);
  };
  __proto.pop = function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  };
  __proto.size = function() {
    return this.content.length;
  };
  __proto.bubbleUp = function(_n) {
    var n = _n;
    var element = this.content[n];
    while (n > 0) {
      var parentN = Math.floor((n + 1) / 2) - 1;
      var parent = this.content[parentN];
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  };
  __proto.sinkDown = function(n) {
    var length2 = this.content.length;
    var element = this.content[n];
    var elemScore = this.scoreFunction(element);
    var child1Score;
    while (true) {
      var child2N = (n + 1) * 2;
      var child1N = child2N - 1;
      var swap = null;
      if (child1N < length2) {
        var child1 = this.content[child1N];
        child1Score = this.scoreFunction(child1);
        if (child1Score < elemScore) {
          swap = child1N;
        }
      }
      if (child2N < length2) {
        var child2 = this.content[child2N];
        var child2Score = this.scoreFunction(child2);
        if (child2Score < (swap == null ? elemScore : child1Score)) {
          swap = child2N;
        }
      }
      if (swap !== null) {
        this.content[n] = this.content[swap];
        this.content[swap] = element;
        n = swap;
      } else {
        break;
      }
    }
  };
  return BinaryHeap2;
}();
function splitItems(items, path) {
  var length2 = path.length;
  var groups = [];
  for (var i = 0; i < length2 - 1; ++i) {
    var path1 = parseInt(path[i], 10);
    var path2 = parseInt(path[i + 1], 10);
    groups.push(items.slice(path1, path2));
  }
  return groups;
}
function parseStretchSize(inlineSize, size) {
  if (isNumber(size)) {
    return size;
  }
  var signText = size.charAt(0);
  var sign = signText === "+" ? 1 : signText === "-" ? -1 : 0;
  var nextSize = parseFloat(size);
  if (size.match(/%$/g)) {
    nextSize *= inlineSize / 100;
  }
  if (sign) {
    return inlineSize + nextSize;
  }
  return nextSize;
}
function getExpectedItemInlineSize(item, rowSize) {
  var inlineSize = item.orgInlineSize;
  var contentSize = item.orgContentSize;
  var inlineOffset = item.gridData.inlineOffset || 0;
  var contentOffset = item.gridData.contentOffset || 0;
  if (!inlineSize || !contentSize) {
    return rowSize;
  }
  var ratio = contentSize <= contentOffset ? 1 : (inlineSize - inlineOffset) / (contentSize - contentOffset);
  return ratio * (rowSize - contentOffset) + inlineOffset;
}
var JustifiedGrid = function(_super) {
  __extends4(JustifiedGrid2, _super);
  function JustifiedGrid2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = JustifiedGrid2.prototype;
  __proto.applyGrid = function(items, direction, outline) {
    var _this = this;
    var _a = this.options, attributePrefix = _a.attributePrefix, horizontal = _a.horizontal;
    items.forEach(function(item) {
      if (!item.isUpdating) {
        return;
      }
      var element = item.element;
      var attributes = item.attributes;
      var gridData = item.gridData;
      var inlineOffset = parseFloat(attributes.inlineOffset);
      var contentOffset = parseFloat(attributes.contentOffset);
      if (isNaN(inlineOffset)) {
        inlineOffset = _this.inlineOffset || gridData.inlineOffset || 0;
      }
      if (isNaN(contentOffset)) {
        contentOffset = _this.contentOffset || gridData.contentOffset | 0;
      }
      if (element && !("inlineOffset" in attributes) && !("contentOffset" in attributes) && item.mountState === MOUNT_STATE.MOUNTED) {
        var maintainedTarget = element.querySelector("[" + attributePrefix + "maintained-target]");
        if (maintainedTarget) {
          var widthOffset = element.offsetWidth - element.clientWidth + element.scrollWidth - maintainedTarget.clientWidth;
          var heightOffset = element.offsetHeight - element.clientHeight + element.scrollHeight - maintainedTarget.clientHeight;
          if (horizontal) {
            inlineOffset = heightOffset;
            contentOffset = widthOffset;
          } else {
            inlineOffset = widthOffset;
            contentOffset = heightOffset;
          }
        }
      }
      gridData.inlineOffset = inlineOffset;
      gridData.contentOffset = contentOffset;
    });
    var rowRange = this.options.rowRange;
    var path = [];
    var isEndDirection = direction === "end";
    if (items.length) {
      path = rowRange ? this._getRowPath(items, isEndDirection) : this._getPath(items, isEndDirection);
    }
    return this._setStyle(items, path, outline, direction === "end");
  };
  __proto._getRowPath = function(items, isEndDirection) {
    var _a;
    var columnRange = this._getColumnRange();
    var rowRange = this._getRowRange();
    var pathLink = this._getRowLink(items, {
      path: [0],
      cost: 0,
      length: 0,
      currentNode: 0
    }, columnRange, rowRange, isEndDirection);
    return (_a = pathLink === null || pathLink === void 0 ? void 0 : pathLink.path.map(function(node) {
      return "" + node;
    })) !== null && _a !== void 0 ? _a : [];
  };
  __proto._getRowLink = function(items, currentLink, columnRange, rowRange, isEndDirection) {
    var minColumn = columnRange[0];
    var minRow = rowRange[0], maxRow = rowRange[1];
    var lastNode = items.length;
    var path = currentLink.path, pathLength = currentLink.length, cost = currentLink.cost, currentNode = currentLink.currentNode;
    if (currentNode < lastNode && (maxRow <= pathLength || currentNode + minColumn > lastNode)) {
      var rangeCost = getRangeCost(lastNode - currentNode, columnRange);
      var lastCost = rangeCost * Math.abs(this._getCost(items, currentNode, lastNode, isEndDirection));
      return __assign2(__assign2({}, currentLink), {
        length: pathLength + 1,
        path: __spreadArray(__spreadArray([], path), [lastNode]),
        currentNode: lastNode,
        cost: cost + lastCost,
        isOver: true
      });
    } else if (currentNode >= lastNode) {
      return __assign2(__assign2({}, currentLink), {
        currentNode: lastNode,
        isOver: minRow > pathLength || maxRow < pathLength
      });
    } else {
      return this._searchRowLink(items, currentLink, lastNode, columnRange, rowRange, isEndDirection);
    }
  };
  __proto._searchRowLink = function(items, currentLink, lastNode, columnRange, rowRange, isEndDirection) {
    var minColumn = columnRange[0], maxColumn = columnRange[1];
    var currentNode = currentLink.currentNode, path = currentLink.path, pathLength = currentLink.length, cost = currentLink.cost;
    var length2 = Math.min(lastNode, currentNode + maxColumn);
    var links = [];
    for (var nextNode = currentNode + minColumn; nextNode <= length2; ++nextNode) {
      if (nextNode === currentNode) {
        continue;
      }
      var nextCost = Math.abs(this._getCost(items, currentNode, nextNode, isEndDirection));
      var nextLink = this._getRowLink(items, {
        path: __spreadArray(__spreadArray([], path), [nextNode]),
        length: pathLength + 1,
        cost: cost + nextCost,
        currentNode: nextNode
      }, columnRange, rowRange, isEndDirection);
      if (nextLink) {
        links.push(nextLink);
      }
    }
    links.sort(function(a, b) {
      var aIsOver = a.isOver;
      var bIsOver = b.isOver;
      if (aIsOver !== bIsOver) {
        return aIsOver ? 1 : -1;
      }
      var aRangeCost = getRangeCost(a.length, rowRange);
      var bRangeCost = getRangeCost(b.length, rowRange);
      return aRangeCost - bRangeCost || a.cost - b.cost;
    });
    return links[0];
  };
  __proto._getExpectedRowSize = function(items, forceStretch) {
    var containerInlineSize = this.getContainerInlineSize() - this.getInlineGap() * (items.length - 1);
    var fixedContainerInsize = containerInlineSize;
    var ratioSum = 0;
    var inlineSum = 0;
    items.forEach(function(item) {
      var inlineSize = item.orgInlineSize;
      var contentSize = item.orgContentSize;
      if (!inlineSize || !contentSize) {
        ratioSum += 1;
        return;
      }
      var inlineOffset = item.gridData.inlineOffset || 0;
      var contentOffset = item.gridData.contentOffset || 0;
      var maintainedRatio = contentSize <= contentOffset ? 1 : (inlineSize - inlineOffset) / (contentSize - contentOffset);
      ratioSum += maintainedRatio;
      inlineSum += contentOffset * maintainedRatio;
      fixedContainerInsize -= inlineOffset;
    });
    if (ratioSum) {
      var nextRowSize = (fixedContainerInsize + inlineSum) / ratioSum;
      if (this.stretch) {
        var _a = this._getSizeRange(), minRowSize = _a[0], maxRowSize = _a[1];
        var stretchRowSize_1 = between(nextRowSize, minRowSize, maxRowSize);
        if (forceStretch) {
          return stretchRowSize_1;
        }
        var stretchRange_1 = this.stretchRange;
        var inlineSizes = items.map(function(item) {
          return getExpectedItemInlineSize(item, stretchRowSize_1);
        });
        var minInlineSize = inlineSizes.reduce(function(prev, itemInlineSize, i) {
          return prev + parseStretchSize(itemInlineSize, items[i].attributes.minStretch || stretchRange_1[0]);
        }, 0);
        var maxInlineSize = inlineSizes.reduce(function(prev, itemInlineSize, i) {
          return prev + parseStretchSize(itemInlineSize, items[i].attributes.maxStretch || stretchRange_1[1]);
        }, 0);
        if (minInlineSize <= containerInlineSize && containerInlineSize <= maxInlineSize) {
          return stretchRowSize_1;
        }
      }
      return nextRowSize;
    }
    return 0;
  };
  __proto._getExpectedInlineSizes = function(items, rowSize) {
    var _a = this.options, stretch = _a.stretch, stretchRange = _a.stretchRange;
    return items.map(function(item) {
      var minInlineSize = stretch ? parseStretchSize(item.orgInlineSize, item.attributes.minStretch || stretchRange[0]) : -Infinity;
      var maxInlineSize = stretch ? parseStretchSize(item.orgInlineSize, item.attributes.maxStretch || stretchRange[1]) : Infinity;
      var itemInlineSize = getExpectedItemInlineSize(item, rowSize);
      var isMax = false;
      var isMin = false;
      if (itemInlineSize >= maxInlineSize) {
        isMax = true;
      } else if (itemInlineSize <= minInlineSize) {
        isMin = true;
      }
      return {
        minSize: minInlineSize,
        maxSize: maxInlineSize,
        size: between(itemInlineSize, minInlineSize, maxInlineSize),
        originalSize: itemInlineSize,
        isMax,
        isMin
      };
    });
  };
  __proto._getStretchItemInfos = function(items, rowSize) {
    var itemsLength = items.length;
    var containerInlineSize = this.getContainerInlineSize() - this.getInlineGap() * (Math.max(1, itemsLength) - 1);
    var itemInfos = this._getExpectedInlineSizes(items, rowSize);
    var firstItemsSize = sum(itemInfos.map(function(info) {
      return info.size;
    }));
    var distSize = containerInlineSize - firstItemsSize;
    var firstScale = containerInlineSize / sum(itemInfos.map(function(info) {
      return info.originalSize;
    }));
    var costInfos = itemInfos.map(function(info) {
      return __assign2(__assign2({}, info), {
        passed: false,
        size: info.originalSize * firstScale
      });
    });
    if (distSize === 0) {
      return {
        infos: costInfos,
        cost: 0
      };
    }
    var isIncrease = distSize > 0;
    var costInfosLength = costInfos.length;
    var _loop_1 = function(i2) {
      var passedItemsSize = sum(costInfos.map(function(info) {
        return info.passed ? info.size : 0;
      }));
      var restItemsSize = sum(costInfos.map(function(info) {
        return info.passed ? 0 : info.originalSize;
      }));
      var distScale = (containerInlineSize - passedItemsSize) / restItemsSize;
      costInfos.forEach(function(info) {
        if (info.passed) {
          return;
        }
        if (isIncrease) {
          if (info.size > info.maxSize) {
            distScale = Math.min(distScale, info.maxSize / info.originalSize);
          }
        } else {
          if (info.size < info.minSize) {
            distScale = Math.max(distScale, info.minSize / info.originalSize);
          }
        }
      });
      costInfos.forEach(function(info) {
        if (!info.passed) {
          info.size = between(info.originalSize * distScale, info.minSize, info.maxSize);
          if (isIncrease && !throttle(info.size - info.maxSize, 1e-3) || !isIncrease && !throttle(info.size - info.minSize, 1e-3)) {
            info.passed = true;
          }
        }
      });
      if (costInfos.every(function(info) {
        return info.passed;
      })) {
        return "break";
      }
    };
    for (var i = 0; i < costInfosLength; ++i) {
      var state_1 = _loop_1();
      if (state_1 === "break") break;
    }
    var lastDistScale = containerInlineSize / sum(costInfos.map(function(info) {
      return info.size;
    }));
    if (throttle(lastDistScale - 1, 1e-3)) {
      costInfos.forEach(function(info) {
        info.size *= lastDistScale;
      });
    }
    return {
      infos: costInfos,
      cost: sum(costInfos.map(function(info) {
        var costRatio = 1;
        if (info.size > info.maxSize || info.size < info.minSize) {
          costRatio = 2;
        }
        var originalSize = info.originalSize;
        if (isIncrease) {
          originalSize = Math.max(originalSize, info.minSize);
        } else {
          originalSize = Math.min(originalSize, info.maxSize);
        }
        return Math.abs(info.size - originalSize) * costRatio;
      }))
    };
  };
  __proto._getExpectedInlineSize = function(items, rowSize) {
    var inlineGap = this.getInlineGap();
    var itemInfos = this._getExpectedInlineSizes(items, rowSize);
    return itemInfos.length ? sum(itemInfos.map(function(info) {
      return info.size;
    })) + inlineGap * (items.length - 1) : 0;
  };
  __proto._getCost = function(items, i, j, isEndDirection) {
    var lineItems = items.slice(i, j);
    var containerInlineSize = this.getContainerInlineSize();
    var rowSize = this._getExpectedRowSize(lineItems);
    var _a = this._getSizeRange(), minSize = _a[0], maxSize = _a[1];
    if (this.isCroppedSize) {
      if (minSize <= rowSize && rowSize <= maxSize) {
        return 0;
      }
      var expectedInlineSize = this._getExpectedInlineSize(lineItems, rowSize < minSize ? minSize : maxSize);
      return Math.pow(expectedInlineSize - containerInlineSize, 2);
    }
    var extraCost = 0;
    if (this.stretch) {
      if (rowSize < minSize) {
        rowSize = minSize;
      } else if (rowSize > maxSize) {
        rowSize = maxSize;
      }
      var sizeCost = Math.abs(rowSize - minSize);
      var expectedInlineSize = this._getExpectedInlineSize(lineItems, rowSize);
      if (!this.passUnstretchRow || (isEndDirection ? j !== items.length : i !== 0) || expectedInlineSize >= containerInlineSize) {
        var res = this._getStretchItemInfos(lineItems, rowSize);
        extraCost = res.cost;
      }
      return extraCost + sizeCost;
    }
    if (isFinite(maxSize)) {
      if (rowSize < minSize) {
        return Math.pow(rowSize - minSize, 2) + Math.pow(maxSize, 2) + extraCost;
      } else if (rowSize > maxSize) {
        return Math.pow(rowSize - maxSize, 2) + Math.pow(maxSize, 2) + extraCost;
      }
    } else if (rowSize < minSize) {
      return Math.max(Math.pow(minSize, 2), Math.pow(rowSize, 2)) + Math.pow(maxSize, 2) + extraCost;
    }
    return rowSize - minSize + extraCost;
  };
  __proto._getPath = function(items, isEndDirection) {
    var _this = this;
    var lastNode = items.length;
    var columnRangeOption = this.options.columnRange;
    var _a = isObject(columnRangeOption) ? columnRangeOption : [columnRangeOption, columnRangeOption], minColumn = _a[0], maxColumn = _a[1];
    var graph = function(nodeKey) {
      var results = {};
      var currentNode = parseInt(nodeKey, 10);
      for (var nextNode = Math.min(currentNode + minColumn, lastNode); nextNode <= lastNode; ++nextNode) {
        if (nextNode - currentNode > maxColumn) {
          break;
        }
        var cost = _this._getCost(items, currentNode, nextNode, isEndDirection);
        if (cost < 0 && nextNode === lastNode) {
          cost = 0;
        }
        results["" + nextNode] = Math.pow(cost, 2);
      }
      return results;
    };
    return find_path(graph, "0", "" + lastNode);
  };
  __proto._setStyle = function(items, path, outline, isEndDirection) {
    var _this = this;
    if (outline === void 0) {
      outline = [];
    }
    var _a = this.options, isCroppedSize = _a.isCroppedSize, displayedRow = _a.displayedRow, stretch = _a.stretch, passUnstretchRow = _a.passUnstretchRow;
    var itemsLength = items.length;
    var sizeRange = this._getSizeRange();
    var startPoint = outline[0] || 0;
    var containerInlineSize = this.getContainerInlineSize();
    var inlineGap = this.getInlineGap();
    var contentGap = this.getContentGap();
    var groups = splitItems(items, path);
    var passedItems;
    var groupsLength = groups.length;
    var contentPos = startPoint;
    var displayedSize = 0;
    var passedPoint;
    groups.forEach(function(groupItems, rowIndex) {
      var groupItemslength = groupItems.length;
      var rowSize = _this._getExpectedRowSize(groupItems, true);
      if (isCroppedSize) {
        rowSize = Math.max(sizeRange[0], Math.min(rowSize, sizeRange[1]));
      }
      var allGap = inlineGap * (length - 1);
      var itemInfos = groupItems.map(function(item, index) {
        var itemInlineSize = getExpectedItemInlineSize(item, rowSize);
        return {
          index,
          item,
          inlineSize: itemInlineSize,
          orgInlineSize: itemInlineSize,
          maxInlineSize: itemInlineSize,
          minInlineSize: itemInlineSize
        };
      });
      var expectedInlineSize = _this._getExpectedInlineSize(groupItems, rowSize);
      var scale = (containerInlineSize - allGap) / (expectedInlineSize - allGap);
      var noGapExpectedContainerInlineSize = expectedInlineSize - allGap;
      var noGapContainerInlineSize = containerInlineSize - allGap;
      if (stretch && expectedInlineSize && noGapContainerInlineSize !== noGapExpectedContainerInlineSize) {
        if (passUnstretchRow && noGapExpectedContainerInlineSize < noGapContainerInlineSize && (isEndDirection ? rowIndex === groupsLength - 1 : rowIndex === 0)) {
          passedPoint = [contentPos];
          passedItems = groupItems.map(function(_, i) {
            return itemsLength - groupItemslength + i;
          });
          var inlineSizes_1 = _this._getExpectedInlineSizes(groupItems, rowSize);
          itemInfos.forEach(function(info, i) {
            info.minInlineSize = inlineSizes_1[i].minSize;
            info.maxInlineSize = inlineSizes_1[i].maxSize;
            info.inlineSize = between(info.inlineSize, info.minInlineSize, info.maxInlineSize);
          });
        } else {
          var infos_1 = _this._getStretchItemInfos(groupItems, rowSize).infos;
          itemInfos.forEach(function(info, i) {
            info.inlineSize = infos_1[i].size;
            info.minInlineSize = infos_1[i].minSize;
            info.maxInlineSize = infos_1[i].maxSize;
          });
        }
      }
      itemInfos.forEach(function(info, i) {
        var item = info.item, inlineSize = info.inlineSize;
        var nextInlineSize = inlineSize;
        var prevItem = groupItems[i - 1];
        var inlinePos = prevItem ? prevItem.cssInlinePos + prevItem.cssInlineSize + inlineGap : 0;
        if (isCroppedSize) {
          nextInlineSize *= scale;
        }
        var gridData = item.gridData;
        gridData.orgInlineSize = info.orgInlineSize;
        gridData.orgContentSize = rowSize;
        gridData.minInlineSize = info.minInlineSize;
        gridData.maxInlineSize = info.maxInlineSize;
        item.setCSSGridRect({
          inlinePos,
          contentPos,
          inlineSize: nextInlineSize,
          contentSize: rowSize
        });
      });
      contentPos += contentGap + rowSize;
      if (displayedRow < 0 || rowIndex < displayedRow) {
        displayedSize = contentPos;
      }
    });
    if (isEndDirection) {
      return {
        start: [startPoint],
        end: [displayedSize],
        passedItems,
        passed: passedPoint
      };
    }
    var height = contentPos - startPoint;
    items.forEach(function(item) {
      item.cssContentPos -= height;
    });
    return {
      passedItems,
      passed: passedPoint ? [passedPoint[0] - height] : null,
      start: [startPoint - height],
      end: [startPoint]
      // endPoint - height = startPoint
    };
  };
  __proto.getComputedOutlineLength = function() {
    return 1;
  };
  __proto.getComputedOutlineSize = function() {
    return this.getContainerInlineSize();
  };
  __proto._getRowRange = function() {
    var rowRange = this.rowRange;
    return isObject(rowRange) ? rowRange : [rowRange, rowRange];
  };
  __proto._getColumnRange = function() {
    var columnRange = this.columnRange;
    return isObject(columnRange) ? columnRange : [columnRange, columnRange];
  };
  __proto._getSizeRange = function() {
    var sizeRange = this.sizeRange;
    return isObject(sizeRange) ? sizeRange : [sizeRange, sizeRange];
  };
  JustifiedGrid2.propertyTypes = __assign2(__assign2({}, Grid.propertyTypes), {
    columnRange: PROPERTY_TYPE.RENDER_PROPERTY,
    rowRange: PROPERTY_TYPE.RENDER_PROPERTY,
    sizeRange: PROPERTY_TYPE.RENDER_PROPERTY,
    isCroppedSize: PROPERTY_TYPE.RENDER_PROPERTY,
    displayedRow: PROPERTY_TYPE.RENDER_PROPERTY,
    stretch: PROPERTY_TYPE.RENDER_PROPERTY,
    stretchRange: PROPERTY_TYPE.RENDER_PROPERTY,
    passUnstretchRow: PROPERTY_TYPE.RENDER_PROPERTY,
    inlineMargin: PROPERTY_TYPE.RENDER_PROPERTY,
    contentMargin: PROPERTY_TYPE.RENDER_PROPERTY,
    inlineOffset: PROPERTY_TYPE.RENDER_PROPERTY,
    contentOffset: PROPERTY_TYPE.RENDER_PROPERTY
  });
  JustifiedGrid2.defaultOptions = __assign2(__assign2({}, Grid.defaultOptions), {
    columnRange: [1, 8],
    rowRange: 0,
    sizeRange: [0, Infinity],
    displayedRow: -1,
    isCroppedSize: false,
    stretch: false,
    passUnstretchRow: true,
    stretchRange: ["-20%", "+20%"],
    inlineOffset: 0,
    contentOffset: 0
  });
  JustifiedGrid2 = __decorate([GetterSetter], JustifiedGrid2);
  return JustifiedGrid2;
}(Grid);
function getMaxPoint(outline) {
  var maxPoint = -Infinity;
  outline.forEach(function(point) {
    if (isFinite(point)) {
      maxPoint = Math.max(maxPoint, point);
    }
  });
  return isFinite(maxPoint) ? maxPoint : 0;
}
function getMinPoint(outline) {
  var minPoint = Infinity;
  outline.forEach(function(point) {
    if (isFinite(point)) {
      minPoint = Math.min(minPoint, point);
    }
  });
  return isFinite(minPoint) ? minPoint : 0;
}
function getOutlinePoint(startOutline, frameOutline, useFrameFill) {
  return getMaxPoint(startOutline) + getOutlineDist(startOutline, frameOutline, useFrameFill);
}
function getOutlineDist(startOutline, endOutline, useFrameFill) {
  var length2 = startOutline.length;
  if (!length2) {
    return 0;
  }
  var minEndPoint = getMinPoint(endOutline);
  var maxStartPoint = getMaxPoint(startOutline);
  var frameDist = 0;
  if (!useFrameFill) {
    return 0;
  }
  for (var outlineIndex = 0; outlineIndex < length2; ++outlineIndex) {
    var startPoint = startOutline[outlineIndex];
    var endPoint = endOutline[outlineIndex];
    if (!isFinite(startPoint) || !isFinite(endPoint)) {
      continue;
    }
    var startPos = startPoint - maxStartPoint;
    var endPos = endPoint - minEndPoint;
    frameDist = outlineIndex ? Math.max(frameDist, frameDist + startPos - endPos) : startPos - endPos;
  }
  return frameDist;
}
function fillOutlines(startOutline, endOutline, rect) {
  var inlinePos = rect.inlinePos, inlineSize = rect.inlineSize, contentPos = rect.contentPos, contentSize = rect.contentSize;
  for (var outlineIndex = inlinePos; outlineIndex < inlinePos + inlineSize; ++outlineIndex) {
    startOutline[outlineIndex] = Math.min(startOutline[outlineIndex], contentPos);
    endOutline[outlineIndex] = Math.max(endOutline[outlineIndex], contentPos + contentSize);
  }
}
var FrameGrid = function(_super) {
  __extends4(FrameGrid2, _super);
  function FrameGrid2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = FrameGrid2.prototype;
  __proto.applyGrid = function(items, direction, outline) {
    var frame = this._getFrame();
    var frameInlineSize = frame.inlineSize, frameContentSize = frame.contentSize, frameRects = frame.rects;
    var useFrameFill = this.options.useFrameFill;
    var _a = this.getRectSize(frameInlineSize), rectInlineSize = _a.inlineSize, rectContentSize = _a.contentSize;
    var inlineGap = this.getInlineGap();
    var contentGap = this.getContentGap();
    var itemsLength = items.length;
    if (!itemsLength || !frameInlineSize || !frameContentSize) {
      return {
        start: outline,
        end: outline
      };
    }
    var rectsLength = frameRects.length;
    var startOutline = range(frameInlineSize).map(function() {
      return Infinity;
    });
    var endOutline = range(frameInlineSize).map(function() {
      return -Infinity;
    });
    var frameOutline = frame.outline.map(function(point) {
      return point * (rectContentSize + contentGap);
    });
    for (var startIndex = 0; startIndex < itemsLength; startIndex += rectsLength) {
      var startPoint = getOutlinePoint(endOutline, frameOutline, useFrameFill);
      for (var rectIndex = 0; rectIndex < rectsLength && startIndex + rectIndex < itemsLength; ++rectIndex) {
        var item = items[startIndex + rectIndex];
        var _b = frameRects[rectIndex], frameRectContentPos = _b.contentPos, frameRectInlinePos = _b.inlinePos, frameRectContentSize = _b.contentSize, frameRectInlineSize = _b.inlineSize;
        var contentPos = startPoint + frameRectContentPos * (rectContentSize + contentGap);
        var inlinePos = frameRectInlinePos * (rectInlineSize + inlineGap);
        var contentSize = frameRectContentSize * (rectContentSize + contentGap) - contentGap;
        var inlineSize = frameRectInlineSize * (rectInlineSize + inlineGap) - inlineGap;
        fillOutlines(startOutline, endOutline, {
          inlinePos: frameRectInlinePos,
          inlineSize: frameRectInlineSize,
          contentPos,
          contentSize: contentSize + contentGap
        });
        item.setCSSGridRect({
          inlinePos,
          contentPos,
          inlineSize,
          contentSize
        });
      }
    }
    var isDirectionEnd = direction === "end";
    var gridOutline = outline.length ? outline : [0];
    if (gridOutline.length !== frameInlineSize) {
      var point_1 = isDirectionEnd ? Math.max.apply(Math, gridOutline) : Math.min.apply(Math, gridOutline);
      gridOutline = range(frameInlineSize).map(function() {
        return point_1;
      });
    }
    startOutline = startOutline.map(function(point) {
      return isFinite(point) ? point : 0;
    });
    endOutline = endOutline.map(function(point) {
      return isFinite(point) ? point : 0;
    });
    var outlineDist = isDirectionEnd ? getOutlinePoint(gridOutline, startOutline, useFrameFill) : getOutlinePoint(endOutline, gridOutline, useFrameFill);
    items.forEach(function(item2) {
      item2.cssContentPos += outlineDist;
    });
    return {
      start: startOutline.map(function(point) {
        return point + outlineDist;
      }),
      end: endOutline.map(function(point) {
        return point + outlineDist;
      })
    };
  };
  __proto.getComputedOutlineLength = function() {
    var frame = this.options.frame;
    return frame.length ? frame[0].length : 0;
  };
  __proto.getComputedOutlineSize = function() {
    var rectSizeOption = this.options.rectSize;
    if (typeof rectSizeOption === "object") {
      return rectSizeOption.inlineSize;
    }
    var inlineGap = this.getInlineGap();
    return rectSizeOption || (this.getContainerInlineSize() + inlineGap) / this.getComputedOutlineLength() - inlineGap;
  };
  __proto.getRectSize = function(frameInlineSize) {
    var rectSizeOption = this.options.rectSize;
    if (typeof rectSizeOption === "object") {
      return rectSizeOption;
    }
    var inlineGap = this.getInlineGap();
    var rectSizeValue = rectSizeOption ? rectSizeOption : (this.getContainerInlineSize() + inlineGap) / frameInlineSize - inlineGap;
    return {
      inlineSize: rectSizeValue,
      contentSize: rectSizeValue
    };
  };
  __proto._getFrame = function() {
    var frame = this.options.frame;
    var frameContentSize = frame.length;
    var frameInlineSize = frameContentSize ? frame[0].length : 0;
    var rects = [];
    var passMap = {};
    var startOutline = range(frameInlineSize).map(function() {
      return Infinity;
    });
    var endOutline = range(frameInlineSize).map(function() {
      return -Infinity;
    });
    for (var y1 = 0; y1 < frameContentSize; ++y1) {
      for (var x1 = 0; x1 < frameInlineSize; ++x1) {
        var type = frame[y1][x1];
        if (!type) {
          continue;
        }
        if (passMap[y1 + "," + x1]) {
          continue;
        }
        var rect = this._findRect(passMap, type, y1, x1, frameInlineSize, frameContentSize);
        fillOutlines(startOutline, endOutline, rect);
        rects.push(rect);
      }
    }
    rects.sort(function(a, b) {
      return a.type < b.type ? -1 : 1;
    });
    return {
      rects,
      inlineSize: frameInlineSize,
      contentSize: frameContentSize,
      outline: startOutline
    };
  };
  __proto._findRect = function(passMap, type, y1, x1, frameInlineSize, frameContentSize) {
    var frame = this.options.frame;
    var contentSize = 1;
    var inlineSize = 1;
    for (var x2 = x1; x2 < frameInlineSize; ++x2) {
      if (frame[y1][x2] === type) {
        inlineSize = x2 - x1 + 1;
        continue;
      }
      break;
    }
    for (var y2 = y1; y2 < frameContentSize; ++y2) {
      if (frame[y2][x1] === type) {
        contentSize = y2 - y1 + 1;
        continue;
      }
      break;
    }
    for (var y = y1; y < y1 + contentSize; ++y) {
      for (var x = x1; x < x1 + inlineSize; ++x) {
        passMap[y + "," + x] = true;
      }
    }
    var rect = {
      type,
      inlinePos: x1,
      contentPos: y1,
      inlineSize,
      contentSize
    };
    return rect;
  };
  FrameGrid2.propertyTypes = __assign2(__assign2({}, Grid.propertyTypes), {
    frame: PROPERTY_TYPE.RENDER_PROPERTY,
    useFrameFill: PROPERTY_TYPE.RENDER_PROPERTY,
    rectSize: PROPERTY_TYPE.RENDER_PROPERTY
  });
  FrameGrid2.defaultOptions = __assign2(__assign2({}, Grid.defaultOptions), {
    frame: [],
    rectSize: 0,
    useFrameFill: true
  });
  FrameGrid2 = __decorate([GetterSetter], FrameGrid2);
  return FrameGrid2;
}(Grid);
var BoxModel = function() {
  function BoxModel2(status) {
    var boxStatus = __assign2({
      orgInlineSize: 0,
      orgContentSize: 0,
      inlineSize: 0,
      contentSize: 0,
      inlinePos: 0,
      contentPos: 0,
      items: []
    }, status);
    for (var name in boxStatus) {
      this[name] = boxStatus[name];
    }
  }
  var __proto = BoxModel2.prototype;
  __proto.scaleTo = function(inlineSize, contentSize) {
    var scaleX = this.inlineSize ? inlineSize / this.inlineSize : 0;
    var scaleY = this.contentSize ? contentSize / this.contentSize : 0;
    this.items.forEach(function(item) {
      if (scaleX !== 0) {
        item.inlinePos *= scaleX;
        item.inlineSize *= scaleX;
      }
      if (scaleY !== 0) {
        item.contentPos *= scaleY;
        item.contentSize *= scaleY;
      }
    });
    this.inlineSize = inlineSize;
    this.contentSize = contentSize;
  };
  __proto.push = function(item) {
    this.items.push(item);
  };
  __proto.getOrgSizeWeight = function() {
    return this.orgInlineSize * this.orgContentSize;
  };
  __proto.getSize = function() {
    return this.inlineSize * this.contentSize;
  };
  __proto.getOrgRatio = function() {
    return this.orgContentSize === 0 ? 0 : this.orgInlineSize / this.orgContentSize;
  };
  __proto.getRatio = function() {
    return this.contentSize === 0 ? 0 : this.inlineSize / this.contentSize;
  };
  return BoxModel2;
}();
function getCost(originLength, length2) {
  var cost = originLength / length2;
  if (cost < 1) {
    cost = 1 / cost;
  }
  return cost - 1;
}
function fitArea(item, bestFitArea, itemFitSize, containerFitSize, isContentDirection) {
  item.contentSize = itemFitSize.contentSize;
  item.inlineSize = itemFitSize.inlineSize;
  bestFitArea.contentSize = containerFitSize.contentSize;
  bestFitArea.inlineSize = containerFitSize.inlineSize;
  if (isContentDirection) {
    item.contentPos = bestFitArea.contentPos + bestFitArea.contentSize;
    item.inlinePos = bestFitArea.inlinePos;
  } else {
    item.inlinePos = bestFitArea.inlinePos + bestFitArea.inlineSize;
    item.contentPos = bestFitArea.contentPos;
  }
}
var PackingGrid = function(_super) {
  __extends4(PackingGrid2, _super);
  function PackingGrid2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = PackingGrid2.prototype;
  __proto.applyGrid = function(items, direction, outline) {
    var _this = this;
    var aspectRatio = this.options.aspectRatio;
    var containerInlineSize = this.getContainerInlineSize();
    var containerContentSize = containerInlineSize / aspectRatio;
    var inlineGap = this.getInlineGap();
    var contentGap = this.getContentGap();
    var prevOutline = outline.length ? outline : [0];
    var startPoint = direction === "end" ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerContentSize - contentGap;
    var endPoint = startPoint + containerContentSize + contentGap;
    var container = new BoxModel({});
    items.forEach(function(item) {
      var model = new BoxModel({
        inlineSize: item.orgInlineSize,
        contentSize: item.orgContentSize,
        orgInlineSize: item.orgInlineSize,
        orgContentSize: item.orgContentSize
      });
      _this._findBestFitArea(container, model);
      container.push(model);
      container.scaleTo(containerInlineSize + inlineGap, containerContentSize + contentGap);
    });
    items.forEach(function(item, i) {
      var boxItem = container.items[i];
      var inlineSize = boxItem.inlineSize - inlineGap;
      var contentSize = boxItem.contentSize - contentGap;
      var contentPos = startPoint + boxItem.contentPos;
      var inlinePos = boxItem.inlinePos;
      item.setCSSGridRect({
        inlinePos,
        contentPos,
        inlineSize,
        contentSize
      });
    });
    return {
      start: [startPoint],
      end: [endPoint]
    };
  };
  __proto._findBestFitArea = function(container, item) {
    if (container.getRatio() === 0) {
      container.orgInlineSize = item.inlineSize;
      container.orgContentSize = item.contentSize;
      container.inlineSize = item.inlineSize;
      container.contentSize = item.contentSize;
      return;
    }
    var bestFitArea;
    var minCost = Infinity;
    var isContentDirection = false;
    var itemFitSize = {
      inlineSize: 0,
      contentSize: 0
    };
    var containerFitSize = {
      inlineSize: 0,
      contentSize: 0
    };
    var sizeWeight = this._getWeight("size");
    var ratioWeight = this._getWeight("ratio");
    container.items.forEach(function(child) {
      var containerSizeCost = getCost(child.getOrgSizeWeight(), child.getSize()) * sizeWeight;
      var containerRatioCost = getCost(child.getOrgRatio(), child.getRatio()) * ratioWeight;
      var inlineSize = child.inlineSize;
      var contentSize = child.contentSize;
      for (var i = 0; i < 2; ++i) {
        var itemInlineSize = void 0;
        var itemContentSize = void 0;
        var containerInlineSize = void 0;
        var containerContentSize = void 0;
        if (i === 0) {
          itemInlineSize = inlineSize;
          itemContentSize = contentSize * (item.contentSize / (child.orgContentSize + item.contentSize));
          containerInlineSize = inlineSize;
          containerContentSize = contentSize - itemContentSize;
        } else {
          itemContentSize = contentSize;
          itemInlineSize = inlineSize * (item.inlineSize / (child.orgInlineSize + item.inlineSize));
          containerContentSize = contentSize;
          containerInlineSize = inlineSize - itemInlineSize;
        }
        var itemSize = itemInlineSize * itemContentSize;
        var itemRatio = itemInlineSize / itemContentSize;
        var containerSize = containerInlineSize * containerContentSize;
        var containerRatio = containerContentSize / containerContentSize;
        var cost = getCost(item.getSize(), itemSize) * sizeWeight;
        cost += getCost(item.getRatio(), itemRatio) * ratioWeight;
        cost += getCost(child.getOrgSizeWeight(), containerSize) * sizeWeight - containerSizeCost;
        cost += getCost(child.getOrgRatio(), containerRatio) * ratioWeight - containerRatioCost;
        if (cost === Math.min(cost, minCost)) {
          minCost = cost;
          bestFitArea = child;
          isContentDirection = i === 0;
          itemFitSize.inlineSize = itemInlineSize;
          itemFitSize.contentSize = itemContentSize;
          containerFitSize.inlineSize = containerInlineSize;
          containerFitSize.contentSize = containerContentSize;
        }
      }
    });
    fitArea(item, bestFitArea, itemFitSize, containerFitSize, isContentDirection);
  };
  __proto.getComputedOutlineLength = function() {
    return 1;
  };
  __proto.getComputedOutlineSize = function() {
    return this.getContainerInlineSize();
  };
  __proto._getWeight = function(type) {
    var options = this.options;
    var weightPriority = options.weightPriority;
    if (weightPriority === type) {
      return 100;
    } else if (weightPriority === "custom") {
      return options[type + "Weight"];
    }
    return 1;
  };
  PackingGrid2.propertyTypes = __assign2(__assign2({}, Grid.propertyTypes), {
    aspectRatio: PROPERTY_TYPE.RENDER_PROPERTY,
    sizeWeight: PROPERTY_TYPE.RENDER_PROPERTY,
    ratioWeight: PROPERTY_TYPE.RENDER_PROPERTY,
    weightPriority: PROPERTY_TYPE.RENDER_PROPERTY
  });
  PackingGrid2.defaultOptions = __assign2(__assign2({}, Grid.defaultOptions), {
    aspectRatio: 1,
    sizeWeight: 1,
    ratioWeight: 1,
    weightPriority: "custom"
  });
  PackingGrid2 = __decorate([GetterSetter], PackingGrid2);
  return PackingGrid2;
}(Grid);
var grid_esm_default = Grid;

// node_modules/@cfcs/core/dist/cfcs.esm.js
function isString3(val) {
  return typeof val === "string";
}
function findTarget(target) {
  var el;
  if (!target) {
    return null;
  }
  if (isString3(target)) {
    el = document.querySelector(target);
  } else if (target instanceof Element) {
    el = target;
  } else if ("value" in target || "current" in target) {
    el = target.value || target.current;
  }
  return el;
}
function withClassMethods(methods) {
  return function(prototype, memberName) {
    methods.forEach(function(name) {
      if (name in prototype) {
        return;
      }
      prototype[name] = function() {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var result = (_a = this[memberName])[name].apply(_a, args);
        if (result === this[memberName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}
var Observer2 = function() {
  function Observer3(value) {
    this._emitter = new component_esm_default();
    this._current = value;
  }
  var __proto = Observer3.prototype;
  Object.defineProperty(__proto, "current", {
    get: function() {
      return this._current;
    },
    set: function(value) {
      var isUpdate = value !== this._current;
      this._current = value;
      if (isUpdate) {
        this._emitter.trigger("update", value);
      }
    },
    enumerable: false,
    configurable: true
  });
  __proto.subscribe = function(callback) {
    this._emitter.on("update", callback);
  };
  __proto.unsubscribe = function(callback) {
    this._emitter.off("update", callback);
  };
  return Observer3;
}();

// node_modules/@egjs/infinitegrid/dist/infinitegrid.esm.js
var extendStatics5 = function(d, b) {
  extendStatics5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics5(d, b);
};
function __extends5(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics5(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign3 = function() {
  __assign3 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray2(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var ua2 = typeof window !== "undefined" ? window.navigator.userAgent : "";
var IS_IOS = /iPhone|iPad/.test(ua2);
var CONTAINER_CLASS_NAME = "infinitegrid-container";
var IGNORE_PROPERITES_MAP = {
  renderOnPropertyChange: true,
  useFit: true,
  autoResize: true
};
var INFINITEGRID_PROPERTY_TYPES = __assign3({}, GRID_PROPERTY_TYPES);
var DIRECTION = {
  START: "start",
  END: "end",
  NONE: ""
};
var INFINITEGRID_EVENTS = {
  CHANGE_SCROLL: "changeScroll",
  REQUEST_APPEND: "requestAppend",
  REQUEST_PREPEND: "requestPrepend",
  RENDER_COMPLETE: "renderComplete",
  CONTENT_ERROR: "contentError"
};
var ITEM_INFO_PROPERTIES = {
  type: true,
  groupKey: true,
  key: true,
  element: true,
  html: true,
  data: true,
  inserted: true,
  attributes: true
};
var INFINITEGRID_METHODS = ["insertByGroupIndex", "updateItems", "getItems", "getVisibleItems", "getGroups", "getVisibleGroups", "renderItems", "getContainerElement", "getScrollContainerElement", "getWrapperElement", "setStatus", "getStatus", "removePlaceholders", "prependPlaceholders", "appendPlaceholders", "getStartCursor", "getEndCursor", "setCursors"];
var GROUP_TYPE;
(function(GROUP_TYPE2) {
  GROUP_TYPE2[GROUP_TYPE2["NORMAL"] = 0] = "NORMAL";
  GROUP_TYPE2[GROUP_TYPE2["VIRTUAL"] = 1] = "VIRTUAL";
  GROUP_TYPE2[GROUP_TYPE2["LOADING"] = 2] = "LOADING";
})(GROUP_TYPE || (GROUP_TYPE = {}));
var ITEM_TYPE;
(function(ITEM_TYPE2) {
  ITEM_TYPE2[ITEM_TYPE2["NORMAL"] = 0] = "NORMAL";
  ITEM_TYPE2[ITEM_TYPE2["VIRTUAL"] = 1] = "VIRTUAL";
  ITEM_TYPE2[ITEM_TYPE2["LOADING"] = 2] = "LOADING";
})(ITEM_TYPE || (ITEM_TYPE = {}));
var STATUS_TYPE;
(function(STATUS_TYPE2) {
  STATUS_TYPE2[STATUS_TYPE2["NOT_REMOVE"] = 0] = "NOT_REMOVE";
  STATUS_TYPE2[STATUS_TYPE2["MINIMIZE_INVISIBLE_ITEMS"] = 1] = "MINIMIZE_INVISIBLE_ITEMS";
  STATUS_TYPE2[STATUS_TYPE2["MINIMIZE_INVISIBLE_GROUPS"] = 2] = "MINIMIZE_INVISIBLE_GROUPS";
  STATUS_TYPE2[STATUS_TYPE2["REMOVE_INVISIBLE_GROUPS"] = 3] = "REMOVE_INVISIBLE_GROUPS";
})(STATUS_TYPE || (STATUS_TYPE = {}));
var INVISIBLE_POS = -9999;
var InfiniteGridItem = function(_super) {
  __extends5(InfiniteGridItem2, _super);
  function InfiniteGridItem2(horizontal, itemStatus) {
    var _this = _super.call(this, horizontal, __assign3({
      html: "",
      type: ITEM_TYPE.NORMAL,
      cssRect: {
        top: INVISIBLE_POS,
        left: INVISIBLE_POS
      }
    }, itemStatus)) || this;
    if (_this.type === ITEM_TYPE.VIRTUAL) {
      if (_this.rect.width || _this.rect.height) {
        _this.mountState = MOUNT_STATE.UNMOUNTED;
      }
      var orgRect = _this.orgRect;
      var rect = _this.rect;
      var cssRect = _this.cssRect;
      if (cssRect.width) {
        rect.width = cssRect.width;
      } else if (orgRect.width) {
        rect.width = orgRect.width;
      }
      if (cssRect.height) {
        rect.height = cssRect.height;
      } else if (orgRect.height) {
        rect.height = orgRect.height;
      }
    }
    return _this;
  }
  var __proto = InfiniteGridItem2.prototype;
  __proto.getVirtualStatus = function() {
    return {
      type: ITEM_TYPE.VIRTUAL,
      groupKey: this.groupKey,
      key: this.key,
      orgRect: this.orgRect,
      rect: this.rect,
      cssRect: this.cssRect,
      attributes: this.attributes
    };
  };
  __proto.getMinimizedStatus = function() {
    var status = __assign3(__assign3({}, _super.prototype.getMinimizedStatus.call(this)), {
      type: ITEM_TYPE.NORMAL,
      groupKey: this.groupKey
    });
    if (this.html) {
      status.html = this.html;
    }
    return status;
  };
  return InfiniteGridItem2;
}(GridItem);
var LOADING_GROUP_KEY = "__INFINITEGRID__LOADING_GRID";
var LOADING_ITEM_KEY = "__INFINITEGRID__LOADING_ITEM";
var LoadingGrid = function(_super) {
  __extends5(LoadingGrid2, _super);
  function LoadingGrid2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "";
    _this.isWaitEnd = false;
    _this.initialDisplay = null;
    return _this;
  }
  var __proto = LoadingGrid2.prototype;
  __proto.getLoadingItem = function() {
    return this.items[0] || null;
  };
  __proto.startLoading = function() {
    var element = this.items[0].element;
    if (element) {
      if (this.initialDisplay != null) {
        this.initialDisplay = element.style.display || "";
      } else if (this.initialDisplay) {
        element.style.display = this.initialDisplay;
      } else {
        element.style.removeProperty("display");
      }
    }
  };
  __proto.endLoading = function() {
    if (this.type) {
      var element = this.items[0].element;
      if (element) {
        element.style.display = "none";
      }
    }
  };
  __proto.setLoadingItem = function(item) {
    if (item) {
      var loadingItem = this.getLoadingItem();
      if (!loadingItem) {
        this.items = [new InfiniteGridItem(this.options.horizontal, __assign3(__assign3({}, item), {
          type: ITEM_TYPE.LOADING,
          key: LOADING_ITEM_KEY
        }))];
      } else {
        for (var name in item) {
          loadingItem[name] = item[name];
        }
      }
    } else {
      this.items = [];
    }
  };
  __proto.applyGrid = function(items, direction, outline) {
    if (!items.length) {
      return {
        start: outline,
        end: outline
      };
    }
    var nextOutline = outline.length ? __spreadArray2([], outline, true) : [0];
    var item = items[0];
    var offset = item.contentSize + this.getContentGap();
    item.cssInlinePos = this.getContainerInlineSize() / 2 - item.inlineSize / 2;
    if (direction === "end") {
      var maxPos = Math.max.apply(Math, nextOutline);
      item.cssContentPos = maxPos;
      return {
        start: nextOutline,
        end: nextOutline.map(function(pos) {
          return pos + offset;
        })
      };
    } else {
      var minPos = Math.min.apply(Math, nextOutline);
      item.cssContentPos = minPos - offset;
      return {
        start: nextOutline.map(function(pos) {
          return pos - offset;
        }),
        end: nextOutline
      };
    }
  };
  return LoadingGrid2;
}(grid_esm_default);
function isWindow2(el) {
  return el === window;
}
function isNumber2(val) {
  return typeof val === "number";
}
function isString4(val) {
  return typeof val === "string";
}
function isObject2(val) {
  return typeof val === "object";
}
function flat(arr) {
  return arr.reduce(function(prev, cur) {
    return __spreadArray2(__spreadArray2([], prev, true), cur, true);
  }, []);
}
function splitOptions(options) {
  var gridOptions = options.gridOptions, otherOptions = __rest(options, ["gridOptions"]);
  return __assign3(__assign3({}, splitGridOptions(gridOptions)), otherOptions);
}
function splitGridOptions(options) {
  var nextOptions = {};
  var gridOptions = {};
  var defaultOptions = grid_esm_default.defaultOptions;
  for (var name in options) {
    var value = options[name];
    if (!(name in IGNORE_PROPERITES_MAP)) {
      gridOptions[name] = value;
    }
    if (name in defaultOptions) {
      nextOptions[name] = value;
    }
  }
  return __assign3(__assign3({}, nextOptions), {
    gridOptions
  });
}
function categorize(items) {
  var groups = [];
  var groupKeys = {};
  var registeredGroupKeys = {};
  items.filter(function(item) {
    return item.groupKey != null;
  }).forEach(function(_a) {
    var groupKey = _a.groupKey;
    registeredGroupKeys[groupKey] = true;
  });
  var generatedGroupKey;
  var isContinuousGroupKey = false;
  items.forEach(function(item, i) {
    if (item.groupKey != null) {
      isContinuousGroupKey = false;
    } else if (!item.inserted && items[i - 1]) {
      item.groupKey = items[i - 1].groupKey;
      isContinuousGroupKey = false;
    } else {
      if (!isContinuousGroupKey) {
        generatedGroupKey = makeKey(registeredGroupKeys);
        isContinuousGroupKey = true;
        registeredGroupKeys[generatedGroupKey] = true;
      }
      item.groupKey = generatedGroupKey;
    }
    var groupKey = item.groupKey;
    var group = groupKeys[groupKey];
    if (!group) {
      group = {
        groupKey,
        items: []
      };
      groupKeys[groupKey] = group;
      groups.push(group);
    }
    group.items.push(item);
  });
  return groups;
}
function getNextCursors(prevKeys, nextKeys, prevStartCursor, prevEndCursor) {
  var result = diff(prevKeys, nextKeys, function(key) {
    return key;
  });
  var nextStartCursor = -1;
  var nextEndCursor = -1;
  result.maintained.forEach(function(_a) {
    var prevIndex = _a[0], nextIndex = _a[1];
    if (prevStartCursor <= prevIndex && prevIndex <= prevEndCursor) {
      if (nextStartCursor === -1) {
        nextStartCursor = nextIndex;
        nextEndCursor = nextIndex;
      } else {
        nextStartCursor = Math.min(nextStartCursor, nextIndex);
        nextEndCursor = Math.max(nextEndCursor, nextIndex);
      }
    }
  });
  return {
    startCursor: nextStartCursor,
    endCursor: nextEndCursor
  };
}
function splitVirtualGroups(groups, direction, nextGroups) {
  var virtualGroups = [];
  if (direction === "start") {
    var index = findIndex(groups, function(group) {
      return group.type === GROUP_TYPE.NORMAL;
    });
    if (index === -1) {
      return [];
    }
    var endMaintainedIndex = findIndex(groups, function(group) {
      return findIndex(nextGroups, function(nextGroup) {
        return nextGroup.groupKey === group.groupKey;
      }) >= 0;
    });
    var endIndex = endMaintainedIndex >= 0 ? Math.min(index, endMaintainedIndex) : index;
    virtualGroups = groups.slice(0, endIndex);
  } else {
    var index = findLastIndex(groups, function(group) {
      return group.type === GROUP_TYPE.NORMAL;
    });
    if (index === -1) {
      return [];
    }
    var startMaintainedIndex = findLastIndex(groups, function(group) {
      return findIndex(nextGroups, function(nextGroup) {
        return nextGroup.groupKey === group.groupKey;
      }) >= 0;
    });
    var startIndex = startMaintainedIndex >= 0 ? Math.max(index, startMaintainedIndex) : index;
    virtualGroups = groups.slice(startIndex + 1);
  }
  return virtualGroups;
}
function getFirstRenderingItems(nextItems, horizontal) {
  var groups = categorize(nextItems);
  if (!groups[0]) {
    return [];
  }
  return groups[0].items.map(function(item) {
    return new InfiniteGridItem(horizontal, __assign3({}, item));
  });
}
function getRenderingItemsByStatus(groupManagerStatus, nextItems, usePlaceholder, horizontal) {
  var prevGroups = groupManagerStatus.groups;
  var groups = categorize(nextItems);
  var startVirtualGroups = splitVirtualGroups(prevGroups, "start", groups);
  var endVirtualGroups = splitVirtualGroups(prevGroups, "end", groups);
  var nextGroups = __spreadArray2(__spreadArray2(__spreadArray2([], startVirtualGroups, true), groups, true), endVirtualGroups, true);
  var _a = getNextCursors(prevGroups.map(function(group) {
    return group.groupKey;
  }), nextGroups.map(function(group) {
    return group.groupKey;
  }), groupManagerStatus.cursors[0], groupManagerStatus.cursors[1]), startCursor = _a.startCursor, endCursor = _a.endCursor;
  var nextVisibleItems = flat(nextGroups.slice(startCursor, endCursor + 1).map(function(group) {
    return group.items.map(function(item) {
      return new InfiniteGridItem(horizontal, __assign3({}, item));
    });
  }));
  if (!usePlaceholder) {
    nextVisibleItems = nextVisibleItems.filter(function(item) {
      return item.type !== ITEM_TYPE.VIRTUAL;
    });
  }
  return nextVisibleItems;
}
function mountRenderingItems(items, options) {
  var grid = options.grid, usePlaceholder = options.usePlaceholder, useLoading = options.useLoading, useFirstRender = options.useFirstRender, status = options.status;
  if (!grid) {
    return;
  }
  if (usePlaceholder) {
    grid.setPlaceholder({});
  }
  if (useLoading) {
    grid.setLoading({});
  }
  if (status) {
    grid.setStatus(status, true);
  }
  grid.syncItems(items);
  if (useFirstRender && !status && grid.getGroups().length) {
    grid.setCursors(0, 0, true);
  }
}
function getRenderingItems(items, options) {
  var status = options.status, usePlaceholder = options.usePlaceholder, useLoading = options.useLoading, horizontal = options.horizontal, useFirstRender = options.useFirstRender, grid = options.grid;
  var visibleItems = [];
  if (grid) {
    grid.setPlaceholder(usePlaceholder ? {} : null);
    grid.setLoading(useLoading ? {} : null);
    grid.syncItems(items);
    visibleItems = grid.getRenderingItems();
  } else if (status) {
    visibleItems = getRenderingItemsByStatus(status.groupManager, items, !!usePlaceholder, !!horizontal);
  } else if (useFirstRender) {
    visibleItems = getFirstRenderingItems(items, !!horizontal);
  }
  return visibleItems;
}
function InfiniteGridGetterSetter(component) {
  var prototype = component.prototype, propertyTypes = component.propertyTypes;
  var _loop_1 = function(name2) {
    var attributes = {
      enumerable: true,
      configurable: true,
      get: function() {
        var options = this.groupManager.options;
        if (name2 in options) {
          return options[name2];
        } else {
          return options.gridOptions[name2];
        }
      },
      set: function(value) {
        var _a;
        var prevValue = this.groupManager[name2];
        if (prevValue === value) {
          return;
        }
        this.groupManager.gridOptions = (_a = {}, _a[name2] = value, _a);
      }
    };
    Object.defineProperty(prototype, name2, attributes);
  };
  for (var name in propertyTypes) {
    _loop_1(name);
  }
}
function makeKey(registeredKeys, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }
  var index = 0;
  while (true) {
    var key = "infinitegrid_".concat(prefix).concat(index++);
    if (!(key in registeredKeys)) {
      return key;
    }
  }
}
function convertHTMLtoElement(html) {
  var dummy = document.createElement("div");
  dummy.innerHTML = html;
  return toArray2(dummy.children);
}
function convertInsertedItems(items, groupKey) {
  var insertedItems;
  if (isString4(items)) {
    insertedItems = convertHTMLtoElement(items);
  } else {
    insertedItems = items;
  }
  return insertedItems.map(function(item) {
    var element;
    var html = "";
    var key;
    if (isString4(item)) {
      html = item;
    } else if ("parentNode" in item) {
      element = item;
      html = item.outerHTML;
    } else {
      return __assign3({
        groupKey,
        inserted: true
      }, item);
    }
    return {
      key,
      groupKey,
      html,
      element,
      inserted: true
    };
  });
}
function toArray2(nodes) {
  var array = [];
  if (nodes) {
    var length2 = nodes.length;
    for (var i = 0; i < length2; i++) {
      array.push(nodes[i]);
    }
  }
  return array;
}
function findIndex(arr, callback) {
  var length2 = arr.length;
  for (var i = 0; i < length2; ++i) {
    if (callback(arr[i], i)) {
      return i;
    }
  }
  return -1;
}
function findLastIndex(arr, callback) {
  var length2 = arr.length;
  for (var i = length2 - 1; i >= 0; --i) {
    if (callback(arr[i], i)) {
      return i;
    }
  }
  return -1;
}
function getItemInfo(info) {
  var nextInfo = {};
  for (var name in info) {
    if (name in ITEM_INFO_PROPERTIES) {
      nextInfo[name] = info[name];
    }
  }
  return nextInfo;
}
function setPlaceholder(item, info) {
  for (var name in info) {
    var value = info[name];
    if (isObject2(value)) {
      item[name] = __assign3(__assign3({}, item[name]), value);
    } else {
      item[name] = info[name];
    }
  }
}
function isFlatOutline(start, end) {
  return start.length === end.length && start.every(function(pos, i) {
    return end[i] === pos;
  });
}
function range2(length2) {
  var arr = [];
  for (var i = 0; i < length2; ++i) {
    arr.push(i);
  }
  return arr;
}
function flatGroups(groups) {
  return flat(groups.map(function(_a) {
    var grid = _a.grid;
    return grid.getItems();
  }));
}
function filterVirtuals(items, includePlaceholders) {
  if (includePlaceholders) {
    return __spreadArray2([], items, true);
  } else {
    return items.filter(function(item) {
      return item.type !== ITEM_TYPE.VIRTUAL;
    });
  }
}
var withInfiniteGridMethods = withClassMethods(INFINITEGRID_METHODS);
var GroupManager = function(_super) {
  __extends5(GroupManager2, _super);
  function GroupManager2(container, options) {
    var _this = _super.call(this, container, splitOptions(options)) || this;
    _this.groupItems = [];
    _this.groups = [];
    _this.itemKeys = {};
    _this.groupKeys = {};
    _this.startCursor = 0;
    _this.endCursor = 0;
    _this._placeholder = null;
    _this._loadingGrid = new LoadingGrid(container, {
      externalContainerManager: _this.containerManager,
      useFit: false,
      autoResize: false,
      renderOnPropertyChange: false,
      gap: _this.gap
    });
    _this._mainGrid = _this._makeGrid();
    return _this;
  }
  var __proto = GroupManager2.prototype;
  Object.defineProperty(__proto, "gridOptions", {
    set: function(options) {
      var _a = splitGridOptions(options), gridOptions = _a.gridOptions, otherOptions = __rest(_a, ["gridOptions"]);
      var shouldRender = this._checkShouldRender(options);
      this.options.gridOptions = __assign3(__assign3({}, this.options.gridOptions), gridOptions);
      __spreadArray2([this._mainGrid], this.groups.map(function(_a2) {
        var grid = _a2.grid;
        return grid;
      }), true).forEach(function(grid) {
        for (var name2 in options) {
          grid[name2] = options[name2];
        }
      });
      for (var name in otherOptions) {
        this[name] = otherOptions[name];
      }
      this._loadingGrid.gap = this.gap;
      if (shouldRender) {
        this.scheduleRender();
      }
    },
    enumerable: false,
    configurable: true
  });
  __proto.getItemByKey = function(key) {
    return this.itemKeys[key] || null;
  };
  __proto.getGroupItems = function(includePlaceholders) {
    return filterVirtuals(this.groupItems, includePlaceholders);
  };
  __proto.getVisibleItems = function(includePlaceholders) {
    return filterVirtuals(this.items, includePlaceholders);
  };
  __proto.getRenderingItems = function() {
    if (this.hasPlaceholder()) {
      return this.items;
    } else {
      return this.items.filter(function(item) {
        return item.type !== ITEM_TYPE.VIRTUAL;
      });
    }
  };
  __proto.getGroups = function(includePlaceholders) {
    return filterVirtuals(this.groups, includePlaceholders);
  };
  __proto.hasVisibleVirtualGroups = function() {
    return this.getVisibleGroups(true).some(function(group) {
      return group.type === GROUP_TYPE.VIRTUAL;
    });
  };
  __proto.hasPlaceholder = function() {
    return !!this._placeholder;
  };
  __proto.hasLoadingItem = function() {
    return !!this._getLoadingItem();
  };
  __proto.updateItems = function(items, options) {
    if (items === void 0) {
      items = this.groupItems;
    }
    return _super.prototype.updateItems.call(this, items, options);
  };
  __proto.setPlaceholder = function(placeholder) {
    this._placeholder = placeholder;
    this._updatePlaceholder();
  };
  __proto.getLoadingType = function() {
    return this._loadingGrid.type;
  };
  __proto.startLoading = function(type) {
    this._loadingGrid.type = type;
    this.items = this._getRenderingItems();
    return true;
  };
  __proto.waitEndLoading = function() {
    if (this._loadingGrid.type) {
      this._loadingGrid.isWaitEnd = true;
      return true;
    }
    return false;
  };
  __proto.endLoading = function() {
    if (this._loadingGrid.isWaitEnd) {
      var prevType = this._loadingGrid.type;
      this._loadingGrid.type = "";
      this._loadingGrid.endLoading();
      this.items = this._getRenderingItems();
      return !!prevType;
    }
    return false;
  };
  __proto.setLoading = function(loading) {
    this._loadingGrid.setLoadingItem(loading);
    this.items = this._getRenderingItems();
  };
  __proto.getVisibleGroups = function(includePlaceholders) {
    var groups = this.groups.slice(this.startCursor, this.endCursor + 1);
    return filterVirtuals(groups, includePlaceholders);
  };
  __proto.getComputedOutlineLength = function(items) {
    if (items === void 0) {
      items = this.items;
    }
    return this._mainGrid.getComputedOutlineLength(items);
  };
  __proto.getComputedOutlineSize = function(items) {
    if (items === void 0) {
      items = this.items;
    }
    return this._mainGrid.getComputedOutlineSize(items);
  };
  __proto.applyGrid = function(items, direction, outline) {
    var _this = this;
    var renderingGroups = this.groups.slice();
    if (!renderingGroups.length) {
      return {
        start: [],
        end: []
      };
    }
    var loadingGrid = this._loadingGrid;
    if (loadingGrid.getLoadingItem()) {
      if (loadingGrid.type === "start") {
        renderingGroups.unshift(this._getLoadingGroup());
      } else if (loadingGrid.type === "end") {
        renderingGroups.push(this._getLoadingGroup());
      }
    }
    var groups = renderingGroups.slice();
    var nextOutline = outline;
    if (direction === "start") {
      groups.reverse();
    }
    var appliedItemChecker = this.options.appliedItemChecker;
    var groupItems = this.groupItems;
    var outlineLength = this.getComputedOutlineLength(groupItems);
    var outlineSize = this.getComputedOutlineSize(groupItems);
    var itemRenderer = this.itemRenderer;
    var passedItems = [];
    groups.forEach(function(group) {
      var _a, _b;
      var grid = group.grid;
      var gridItems = grid.getItems();
      var isVirtual = group.type === GROUP_TYPE.VIRTUAL && !gridItems[0];
      passedItems = direction === "end" ? __spreadArray2(__spreadArray2([], passedItems, true), gridItems, true) : __spreadArray2(__spreadArray2([], gridItems, true), passedItems, true);
      grid.outlineLength = outlineLength;
      grid.outlineSize = outlineSize;
      var appliedItems = passedItems.filter(function(item) {
        if (item.mountState === MOUNT_STATE.UNCHECKED || !item.rect.width) {
          itemRenderer.updateItem(item, true);
        }
        return item.orgRect.width && item.rect.width || appliedItemChecker(item, grid);
      });
      var gridOutlines;
      if (isVirtual) {
        gridOutlines = _this._applyVirtualGrid(grid, direction, nextOutline);
      } else if (appliedItems.length) {
        gridOutlines = grid.applyGrid(appliedItems, direction, nextOutline);
      } else {
        gridOutlines = {
          start: __spreadArray2([], nextOutline, true),
          end: __spreadArray2([], nextOutline, true)
        };
      }
      grid.setOutlines(gridOutlines);
      nextOutline = gridOutlines.passed || gridOutlines[direction];
      passedItems = (_b = (_a = gridOutlines.passedItems) === null || _a === void 0 ? void 0 : _a.map(function(index) {
        return passedItems[index];
      })) !== null && _b !== void 0 ? _b : [];
    });
    return {
      start: renderingGroups[0].grid.getOutlines().start,
      end: renderingGroups[renderingGroups.length - 1].grid.getOutlines().end
    };
  };
  __proto.syncItems = function(nextItemInfos) {
    var _this = this;
    var prevItemKeys = this.itemKeys;
    this.itemKeys = {};
    var nextItems = this._syncItemInfos(nextItemInfos.map(function(info) {
      return getItemInfo(info);
    }), prevItemKeys);
    var prevGroupKeys = this.groupKeys;
    var nextManagerGroups = categorize(nextItems);
    var startVirtualGroups = this._splitVirtualGroups("start", nextManagerGroups);
    var endVirtualGroups = this._splitVirtualGroups("end", nextManagerGroups);
    nextManagerGroups = __spreadArray2(__spreadArray2(__spreadArray2([], startVirtualGroups, true), this._mergeVirtualGroups(nextManagerGroups), true), endVirtualGroups, true);
    var nextGroups = nextManagerGroups.map(function(_a) {
      var _b, _c;
      var groupKey = _a.groupKey, items = _a.items;
      var isVirtual = !items[0] || items[0].type === ITEM_TYPE.VIRTUAL;
      var grid = (_c = (_b = prevGroupKeys[groupKey]) === null || _b === void 0 ? void 0 : _b.grid) !== null && _c !== void 0 ? _c : _this._makeGrid();
      var gridItems = isVirtual ? items : items.filter(function(_a2) {
        var type = _a2.type;
        return type === ITEM_TYPE.NORMAL;
      });
      grid.setItems(gridItems);
      return {
        type: isVirtual ? GROUP_TYPE.VIRTUAL : GROUP_TYPE.NORMAL,
        groupKey,
        grid,
        items: gridItems,
        renderItems: items
      };
    });
    this._registerGroups(nextGroups);
  };
  __proto.renderItems = function(options) {
    if (options === void 0) {
      options = {};
    }
    if (options.useResize) {
      this.groupItems.forEach(function(item) {
        item.updateState = UPDATE_STATE.NEED_UPDATE;
      });
      var loadingItem = this._getLoadingItem();
      if (loadingItem) {
        loadingItem.updateState = UPDATE_STATE.NEED_UPDATE;
      }
    }
    return _super.prototype.renderItems.call(this, options);
  };
  __proto.setCursors = function(startCursor, endCursor) {
    this.startCursor = startCursor;
    this.endCursor = endCursor;
    this.items = this._getRenderingItems();
  };
  __proto.getStartCursor = function() {
    return this.startCursor;
  };
  __proto.getEndCursor = function() {
    return this.endCursor;
  };
  __proto.getGroupStatus = function(type, includePlaceholders) {
    var orgStartCursor = this.startCursor;
    var orgEndCursor = this.endCursor;
    var orgGroups = this.groups;
    var startGroup = orgGroups[orgStartCursor];
    var endGroup = orgGroups[orgEndCursor];
    var startCursor = orgStartCursor;
    var endCursor = orgEndCursor;
    var isMinimizeItems = type === STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS;
    var isMinimizeGroups = type === STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS;
    var groups;
    if (type === STATUS_TYPE.REMOVE_INVISIBLE_GROUPS) {
      groups = this.getVisibleGroups(includePlaceholders);
      endCursor = groups.length - 1;
      startCursor = 0;
    } else {
      groups = this.getGroups(includePlaceholders);
      if (!includePlaceholders) {
        startCursor = -1;
        endCursor = -1;
        for (var orgIndex = orgStartCursor; orgIndex <= orgEndCursor; ++orgIndex) {
          var orgGroup = orgGroups[orgIndex];
          if (orgGroup && orgGroup.type !== GROUP_TYPE.VIRTUAL) {
            startCursor = groups.indexOf(orgGroup);
            break;
          }
        }
        for (var orgIndex = orgEndCursor; orgIndex >= orgStartCursor; --orgIndex) {
          var orgGroup = orgGroups[orgIndex];
          if (orgGroup && orgGroup.type !== GROUP_TYPE.VIRTUAL) {
            endCursor = groups.lastIndexOf(orgGroup);
            break;
          }
        }
      }
    }
    var groupStatus = groups.map(function(_a, i) {
      var grid = _a.grid, groupKey = _a.groupKey;
      var isOutsideCursor = i < startCursor || endCursor < i;
      var isVirtualItems = isMinimizeItems && isOutsideCursor;
      var isVirtualGroup = isMinimizeGroups && isOutsideCursor;
      var gridItems = grid.getItems();
      var items = isVirtualGroup ? [] : gridItems.map(function(item) {
        return isVirtualItems ? item.getVirtualStatus() : item.getMinimizedStatus();
      });
      return {
        type: isVirtualGroup || isVirtualItems ? GROUP_TYPE.VIRTUAL : GROUP_TYPE.NORMAL,
        groupKey,
        outlines: grid.getOutlines(),
        items
      };
    });
    var totalItems = this.getGroupItems();
    var itemStartCursor = totalItems.indexOf(startGroup === null || startGroup === void 0 ? void 0 : startGroup.items[0]);
    var itemEndCursor = totalItems.indexOf(endGroup === null || endGroup === void 0 ? void 0 : endGroup.items.slice().reverse()[0]);
    return {
      cursors: [startCursor, endCursor],
      orgCursors: [orgStartCursor, orgEndCursor],
      itemCursors: [itemStartCursor, itemEndCursor],
      startGroupKey: startGroup === null || startGroup === void 0 ? void 0 : startGroup.groupKey,
      endGroupKey: endGroup === null || endGroup === void 0 ? void 0 : endGroup.groupKey,
      groups: groupStatus,
      outlines: this.outlines
    };
  };
  __proto.fitOutlines = function(useFit) {
    if (useFit === void 0) {
      useFit = this.useFit;
    }
    var groups = this.groups;
    if (!groups[0]) {
      return;
    }
    var outlines = this.outlines;
    var startOutline = outlines.start;
    var outlineOffset = startOutline.length ? Math.min.apply(Math, startOutline) : 0;
    if (!useFit && outlineOffset > 0) {
      return;
    }
    groups.forEach(function(_a) {
      var grid = _a.grid;
      var _b = grid.getOutlines(), start = _b.start, end = _b.end;
      grid.setOutlines({
        start: start.map(function(point) {
          return point - outlineOffset;
        }),
        end: end.map(function(point) {
          return point - outlineOffset;
        })
      });
    });
    this.groupItems.forEach(function(item) {
      var contentPos = item.cssContentPos;
      if (!isNumber2(contentPos)) {
        return;
      }
      item.cssContentPos = contentPos - outlineOffset;
    });
  };
  __proto.setGroupStatus = function(status) {
    var _this = this;
    this.itemKeys = {};
    this.groupItems = [];
    this.items = [];
    var prevGroupKeys = this.groupKeys;
    var nextGroups = status.groups.map(function(_a) {
      var _b, _c;
      var type = _a.type, groupKey = _a.groupKey, items = _a.items, outlines = _a.outlines;
      var nextItems = _this._syncItemInfos(items);
      var grid = (_c = (_b = prevGroupKeys[groupKey]) === null || _b === void 0 ? void 0 : _b.grid) !== null && _c !== void 0 ? _c : _this._makeGrid();
      grid.setOutlines(outlines);
      grid.setItems(nextItems);
      return {
        type,
        groupKey,
        grid,
        items: nextItems,
        renderItems: nextItems
      };
    });
    this.setOutlines(status.outlines);
    this._registerGroups(nextGroups);
    this._updatePlaceholder();
    this.setCursors(status.cursors[0], status.cursors[1]);
  };
  __proto.appendPlaceholders = function(items, groupKey) {
    return this.insertPlaceholders("end", items, groupKey);
  };
  __proto.prependPlaceholders = function(items, groupKey) {
    return this.insertPlaceholders("start", items, groupKey);
  };
  __proto.removePlaceholders = function(type) {
    var groups = this.groups;
    var length2 = groups.length;
    if (type === "start") {
      var index = findIndex(groups, function(group) {
        return group.type === GROUP_TYPE.NORMAL;
      });
      groups.splice(0, index);
    } else if (type === "end") {
      var index = findLastIndex(groups, function(group) {
        return group.type === GROUP_TYPE.NORMAL;
      });
      groups.splice(index + 1, length2 - index - 1);
    } else {
      var groupKey_1 = type.groupKey;
      var index = findIndex(groups, function(group) {
        return group.groupKey === groupKey_1;
      });
      if (index > -1) {
        groups.splice(index, 1);
      }
    }
    this.syncItems(flatGroups(this.getGroups()));
  };
  __proto.insertPlaceholders = function(direction, items, groupKey) {
    var _a, _b;
    if (groupKey === void 0) {
      groupKey = makeKey(this.groupKeys, "virtual_");
    }
    var infos = [];
    if (isNumber2(items)) {
      infos = range2(items).map(function() {
        return {
          type: ITEM_TYPE.VIRTUAL,
          groupKey
        };
      });
    } else if (Array.isArray(items)) {
      infos = items.map(function(status) {
        return __assign3(__assign3({
          groupKey
        }, status), {
          type: ITEM_TYPE.VIRTUAL
        });
      });
    }
    var grid = this._makeGrid();
    var nextItems = this._syncItemInfos(infos, this.itemKeys);
    this._updatePlaceholder(nextItems);
    grid.setItems(nextItems);
    var group = {
      type: GROUP_TYPE.VIRTUAL,
      groupKey,
      grid,
      items: nextItems,
      renderItems: nextItems
    };
    this.groupKeys[groupKey] = group;
    if (direction === "end") {
      this.groups.push(group);
      (_a = this.groupItems).push.apply(_a, nextItems);
    } else {
      this.groups.splice(0, 0, group);
      (_b = this.groupItems).splice.apply(_b, __spreadArray2([0, 0], nextItems, false));
      if (this.startCursor > -1) {
        ++this.startCursor;
        ++this.endCursor;
      }
    }
    return {
      group,
      items: nextItems
    };
  };
  __proto.shouldRerenderItems = function() {
    var isRerender = false;
    this.getVisibleGroups().forEach(function(group) {
      var items = group.items;
      if (items.length === group.renderItems.length || items.every(function(item) {
        return item.mountState === MOUNT_STATE.UNCHECKED;
      })) {
        return;
      }
      isRerender = true;
      group.renderItems = __spreadArray2([], items, true);
    });
    if (isRerender) {
      this.items = this._getRenderingItems();
    }
    return isRerender;
  };
  __proto._updateItems = function(items) {
    this.itemRenderer.updateEqualSizeItems(items, this.groupItems);
  };
  __proto._getGroupItems = function() {
    return flatGroups(this.getGroups(true));
  };
  __proto._getRenderingItems = function() {
    var items = flat(this.getVisibleGroups(true).map(function(item) {
      return item.renderItems;
    }));
    var loadingGrid = this._loadingGrid;
    var loadingItem = loadingGrid.getLoadingItem();
    if (loadingItem) {
      if (loadingGrid.type === "end") {
        items.push(loadingItem);
      } else if (loadingGrid.type === "start") {
        items.unshift(loadingItem);
      }
    }
    return items;
  };
  __proto._checkShouldRender = function(options) {
    var GridConstructor = this.options.gridConstructor;
    var prevOptions = this.gridOptions;
    var propertyTypes = GridConstructor.propertyTypes;
    for (var name in prevOptions) {
      if (!(name in options) && propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY) {
        return true;
      }
    }
    for (var name in options) {
      if (prevOptions[name] !== options[name] && propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY) {
        return true;
      }
    }
    return false;
  };
  __proto._applyVirtualGrid = function(grid, direction, outline) {
    var startOutline = outline.length ? __spreadArray2([], outline, true) : [0];
    var prevOutlines = grid.getOutlines();
    var prevOutline = prevOutlines[direction === "end" ? "start" : "end"];
    if (prevOutline.length !== startOutline.length || prevOutline.some(function(value, i) {
      return value !== startOutline[i];
    })) {
      return {
        start: __spreadArray2([], startOutline, true),
        end: __spreadArray2([], startOutline, true)
      };
    }
    return prevOutlines;
  };
  __proto._syncItemInfos = function(nextItemInfos, prevItemKeys) {
    if (prevItemKeys === void 0) {
      prevItemKeys = {};
    }
    var horizontal = this.options.horizontal;
    var nextItemKeys = this.itemKeys;
    nextItemInfos.filter(function(info) {
      return info.key != null;
    }).forEach(function(info) {
      var key = info.key;
      var prevItem = prevItemKeys[key];
      if (!prevItem) {
        nextItemKeys[key] = new InfiniteGridItem(horizontal, __assign3({}, info));
      } else if (prevItem.type === ITEM_TYPE.VIRTUAL && info.type !== ITEM_TYPE.VIRTUAL) {
        nextItemKeys[key] = new InfiniteGridItem(horizontal, __assign3({
          orgRect: prevItem.orgRect,
          rect: prevItem.rect
        }, info));
      } else {
        if (info.data) {
          prevItem.data = info.data;
        }
        if (info.groupKey != null) {
          prevItem.groupKey = info.groupKey;
        }
        if (info.element) {
          prevItem.element = info.element;
        }
        nextItemKeys[key] = prevItem;
      }
    });
    var nextItems = nextItemInfos.map(function(info) {
      var key = info.key;
      if (info.key == null) {
        key = makeKey(nextItemKeys, info.type === ITEM_TYPE.VIRTUAL ? "virtual_" : "");
      }
      var item = nextItemKeys[key];
      if (!item) {
        var prevItem = prevItemKeys[key];
        if (prevItem) {
          item = prevItem;
          if (info.data) {
            item.data = info.data;
          }
          if (info.element) {
            item.element = info.element;
          }
        } else {
          item = new InfiniteGridItem(horizontal, __assign3(__assign3({}, info), {
            key
          }));
        }
        nextItemKeys[key] = item;
      }
      return item;
    });
    return nextItems;
  };
  __proto._registerGroups = function(groups) {
    var nextGroupKeys = {};
    groups.forEach(function(group) {
      nextGroupKeys[group.groupKey] = group;
    });
    this.groups = groups;
    this.groupKeys = nextGroupKeys;
    this.groupItems = this._getGroupItems();
  };
  __proto._splitVirtualGroups = function(direction, nextGroups) {
    var groups = splitVirtualGroups(this.groups, direction, nextGroups);
    var itemKeys = this.itemKeys;
    groups.forEach(function(_a) {
      var renderItems = _a.renderItems;
      renderItems.forEach(function(item) {
        itemKeys[item.key] = item;
      });
    });
    return groups;
  };
  __proto._mergeVirtualGroups = function(groups) {
    var itemKeys = this.itemKeys;
    var groupKeys = this.groupKeys;
    groups.forEach(function(group) {
      var prevGroup = groupKeys[group.groupKey];
      if (!prevGroup) {
        return;
      }
      var items = group.items;
      if (items.every(function(item) {
        return item.mountState === MOUNT_STATE.UNCHECKED;
      })) {
        prevGroup.renderItems.forEach(function(item) {
          if (item.type === ITEM_TYPE.VIRTUAL && !itemKeys[item.key]) {
            items.push(item);
            itemKeys[item.key] = item;
          }
        });
      }
    });
    return groups;
  };
  __proto._updatePlaceholder = function(items) {
    if (items === void 0) {
      items = this.groupItems;
    }
    var placeholder = this._placeholder;
    if (!placeholder) {
      return;
    }
    items.filter(function(item) {
      return item.type === ITEM_TYPE.VIRTUAL;
    }).forEach(function(item) {
      setPlaceholder(item, placeholder);
    });
  };
  __proto._makeGrid = function() {
    var GridConstructor = this.options.gridConstructor;
    var gridOptions = this.gridOptions;
    var container = this.containerElement;
    return new GridConstructor(container, __assign3(__assign3({}, gridOptions), {
      useFit: false,
      autoResize: false,
      useResizeObserver: false,
      observeChildren: false,
      renderOnPropertyChange: false,
      externalContainerManager: this.containerManager,
      externalItemRenderer: this.itemRenderer
    }));
  };
  __proto._getLoadingGroup = function() {
    var loadingGrid = this._loadingGrid;
    var items = loadingGrid.getItems();
    return {
      groupKey: LOADING_GROUP_KEY,
      type: GROUP_TYPE.NORMAL,
      grid: loadingGrid,
      items,
      renderItems: items
    };
  };
  __proto._getLoadingItem = function() {
    return this._loadingGrid.getLoadingItem();
  };
  GroupManager2.defaultOptions = __assign3(__assign3({}, grid_esm_default.defaultOptions), {
    appliedItemChecker: function() {
      return false;
    },
    gridConstructor: null,
    gridOptions: {}
  });
  GroupManager2.propertyTypes = __assign3(__assign3({}, grid_esm_default.propertyTypes), {
    gridConstructor: PROPERTY_TYPE.PROPERTY,
    gridOptions: PROPERTY_TYPE.PROPERTY
  });
  GroupManager2 = __decorate2([GetterSetter], GroupManager2);
  return GroupManager2;
}(grid_esm_default);
var Infinite = function(_super) {
  __extends5(Infinite2, _super);
  function Infinite2(options) {
    var _this = _super.call(this) || this;
    _this.startCursor = -1;
    _this.endCursor = -1;
    _this.size = 0;
    _this.items = [];
    _this.itemKeys = {};
    _this.options = __assign3({
      threshold: 0,
      useRecycle: true,
      defaultDirection: "end"
    }, options);
    return _this;
  }
  var __proto = Infinite2.prototype;
  __proto.scroll = function(scrollPos) {
    var _a, _b;
    var prevStartCursor = this.startCursor;
    var prevEndCursor = this.endCursor;
    var items = this.items;
    var length2 = items.length;
    var size = this.size;
    var _c = this.options, defaultDirection = _c.defaultDirection, threshold = _c.threshold, useRecycle = _c.useRecycle;
    var isDirectionEnd = defaultDirection === "end";
    if (!length2) {
      this.trigger(isDirectionEnd ? "requestAppend" : "requestPrepend", {
        key: void 0,
        isVirtual: false
      });
      return;
    } else if (prevStartCursor === -1 || prevEndCursor === -1) {
      var nextCursor = isDirectionEnd ? 0 : length2 - 1;
      this.trigger("change", {
        prevStartCursor,
        prevEndCursor,
        nextStartCursor: nextCursor,
        nextEndCursor: nextCursor
      });
      return;
    }
    var endScrollPos = scrollPos + size;
    var startEdgePos = Math.max.apply(Math, items[prevStartCursor].startOutline);
    var endEdgePos = Math.min.apply(Math, items[prevEndCursor].endOutline);
    var visibles = items.map(function(item) {
      var startOutline = item.startOutline, endOutline = item.endOutline;
      if (!startOutline.length || !endOutline.length || isFlatOutline(startOutline, endOutline)) {
        return false;
      }
      var startPos = Math.min.apply(Math, startOutline);
      var endPos = Math.max.apply(Math, endOutline);
      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {
        return true;
      }
      return false;
    });
    var hasStartItems = 0 < prevStartCursor;
    var hasEndItems = prevEndCursor < length2 - 1;
    var isStart = scrollPos <= startEdgePos + threshold;
    var isEnd = endScrollPos >= endEdgePos - threshold;
    var nextStartCursor = visibles.indexOf(true);
    var nextEndCursor = visibles.lastIndexOf(true);
    if (nextStartCursor === -1) {
      nextStartCursor = prevStartCursor;
      nextEndCursor = prevEndCursor;
    }
    if (!useRecycle) {
      nextStartCursor = Math.min(nextStartCursor, prevStartCursor);
      nextEndCursor = Math.max(nextEndCursor, prevEndCursor);
    }
    if (nextStartCursor === prevStartCursor && hasStartItems && isStart) {
      nextStartCursor -= 1;
    }
    if (nextEndCursor === prevEndCursor && hasEndItems && isEnd) {
      nextEndCursor += 1;
    }
    var nextVisibleItems = items.slice(nextStartCursor, nextEndCursor + 1);
    if (nextVisibleItems.every(function(item) {
      return item.isVirtual === true;
    })) {
      var hasRealItem = false;
      for (var i = nextStartCursor - 1; i >= 0; --i) {
        if (!items[i].isVirtual) {
          nextStartCursor = i;
          hasRealItem = true;
          break;
        }
      }
      if (!hasRealItem) {
        for (var i = nextEndCursor + 1; i < length2; ++i) {
          if (!items[i].isVirtual) {
            nextEndCursor = i;
            hasRealItem = true;
            break;
          }
        }
      }
      if (hasRealItem) {
        nextVisibleItems = items.slice(nextStartCursor, nextEndCursor + 1);
      }
    }
    var hasVirtualItems = nextVisibleItems.some(function(item) {
      return item.isVirtual === true;
    });
    if (prevStartCursor !== nextStartCursor || prevEndCursor !== nextEndCursor) {
      this.trigger("change", {
        prevStartCursor,
        prevEndCursor,
        nextStartCursor,
        nextEndCursor
      });
      if (!hasVirtualItems) {
        return;
      }
    }
    if (hasVirtualItems) {
      var isStartVirtual = (_a = nextVisibleItems[0]) === null || _a === void 0 ? void 0 : _a.isVirtual;
      var isEndVirtual = (_b = nextVisibleItems[nextVisibleItems.length - 1]) === null || _b === void 0 ? void 0 : _b.isVirtual;
      if ((!isDirectionEnd || !isEnd) && isStartVirtual) {
        var realItemIndex = findIndex(nextVisibleItems, function(item) {
          return !item.isVirtual;
        });
        var endVirtualItemIndex = (realItemIndex === -1 ? nextVisibleItems.length : realItemIndex) - 1;
        if (nextVisibleItems[endVirtualItemIndex]) {
          this.trigger("requestPrepend", {
            key: realItemIndex > -1 ? nextVisibleItems[realItemIndex].key : void 0,
            nextKey: nextVisibleItems[endVirtualItemIndex].key,
            nextKeys: nextVisibleItems.slice(0, endVirtualItemIndex + 1).map(function(item) {
              return item.key;
            }),
            isVirtual: true
          });
        }
      } else if ((isDirectionEnd || !isStart) && isEndVirtual) {
        var realItemIndex = findLastIndex(nextVisibleItems, function(item) {
          return !item.isVirtual;
        });
        var startVirtualItemIndex = realItemIndex + 1;
        if (nextVisibleItems[startVirtualItemIndex]) {
          this.trigger("requestAppend", {
            key: realItemIndex > -1 ? nextVisibleItems[realItemIndex].key : void 0,
            nextKey: nextVisibleItems[startVirtualItemIndex].key,
            nextKeys: nextVisibleItems.slice(startVirtualItemIndex).map(function(item) {
              return item.key;
            }),
            isVirtual: true
          });
        }
      }
    } else if (!this._requestVirtualItems()) {
      if ((!isDirectionEnd || !isEnd) && isStart) {
        this.trigger("requestPrepend", {
          key: items[prevStartCursor].key,
          isVirtual: false
        });
      } else if ((isDirectionEnd || !isStart) && isEnd) {
        this.trigger("requestAppend", {
          key: items[prevEndCursor].key,
          isVirtual: false
        });
      }
    }
  };
  __proto._requestVirtualItems = function() {
    var isDirectionEnd = this.options.defaultDirection === "end";
    var items = this.items;
    var totalVisibleItems = this.getVisibleItems();
    var visibleItems = totalVisibleItems.filter(function(item) {
      return !item.isVirtual;
    });
    var totalVisibleLength = totalVisibleItems.length;
    var visibleLength = visibleItems.length;
    var startCursor = this.getStartCursor();
    var endCursor = this.getEndCursor();
    if (visibleLength === totalVisibleLength) {
      return false;
    } else if (visibleLength) {
      var startKey_1 = visibleItems[0].key;
      var endKey_1 = visibleItems[visibleLength - 1].key;
      var startIndex = findIndex(items, function(item) {
        return item.key === startKey_1;
      }) - 1;
      var endIndex = findIndex(items, function(item) {
        return item.key === endKey_1;
      }) + 1;
      var isEnd = endIndex <= endCursor;
      var isStart = startIndex >= startCursor;
      if ((isDirectionEnd || !isStart) && isEnd) {
        this.trigger("requestAppend", {
          key: endKey_1,
          nextKey: items[endIndex].key,
          isVirtual: true
        });
        return true;
      } else if ((!isDirectionEnd || !isEnd) && isStart) {
        this.trigger("requestPrepend", {
          key: startKey_1,
          nextKey: items[startIndex].key,
          isVirtual: true
        });
        return true;
      }
    } else if (totalVisibleLength) {
      var lastItem = totalVisibleItems[totalVisibleLength - 1];
      if (isDirectionEnd) {
        this.trigger("requestAppend", {
          nextKey: totalVisibleItems[0].key,
          isVirtual: true
        });
      } else {
        this.trigger("requestPrepend", {
          nextKey: lastItem.key,
          isVirtual: true
        });
      }
      return true;
    }
    return false;
  };
  __proto.setCursors = function(startCursor, endCursor) {
    this.startCursor = startCursor;
    this.endCursor = endCursor;
  };
  __proto.setSize = function(size) {
    this.size = size;
  };
  __proto.getStartCursor = function() {
    return this.startCursor;
  };
  __proto.getEndCursor = function() {
    return this.endCursor;
  };
  __proto.isLoading = function(direction) {
    var startCursor = this.startCursor;
    var endCursor = this.endCursor;
    var items = this.items;
    var firstItem = items[startCursor];
    var lastItem = items[endCursor];
    var length2 = items.length;
    if (direction === DIRECTION.END && endCursor > -1 && endCursor < length2 - 1 && !lastItem.isVirtual && !isFlatOutline(lastItem.startOutline, lastItem.endOutline)) {
      return false;
    }
    if (direction === DIRECTION.START && startCursor > 0 && !firstItem.isVirtual && !isFlatOutline(firstItem.startOutline, firstItem.endOutline)) {
      return false;
    }
    return true;
  };
  __proto.setItems = function(nextItems) {
    this.items = nextItems;
    var itemKeys = {};
    nextItems.forEach(function(item) {
      itemKeys[item.key] = item;
    });
    this.itemKeys = itemKeys;
  };
  __proto.syncItems = function(nextItems) {
    var prevItems = this.items;
    var prevStartCursor = this.startCursor;
    var prevEndCursor = this.endCursor;
    var _a = getNextCursors(this.items.map(function(item) {
      return item.key;
    }), nextItems.map(function(item) {
      return item.key;
    }), prevStartCursor, prevEndCursor), nextStartCursor = _a.startCursor, nextEndCursor = _a.endCursor;
    var isChange = nextEndCursor - nextStartCursor !== prevEndCursor - prevStartCursor || prevStartCursor === -1 || nextStartCursor === -1;
    if (!isChange) {
      var prevVisibleItems = prevItems.slice(prevStartCursor, prevEndCursor + 1);
      var nextVisibleItems = nextItems.slice(nextStartCursor, nextEndCursor + 1);
      var visibleResult = diff(prevVisibleItems, nextVisibleItems, function(item) {
        return item.key;
      });
      isChange = visibleResult.added.length > 0 || visibleResult.removed.length > 0 || visibleResult.changed.length > 0;
    }
    this.setItems(nextItems);
    this.setCursors(nextStartCursor, nextEndCursor);
    return isChange;
  };
  __proto.getItems = function() {
    return this.items;
  };
  __proto.getVisibleItems = function() {
    var startCursor = this.startCursor;
    var endCursor = this.endCursor;
    if (startCursor === -1) {
      return [];
    }
    return this.items.slice(startCursor, endCursor + 1);
  };
  __proto.getSize = function() {
    return this.size;
  };
  __proto.getItemByKey = function(key) {
    return this.itemKeys[key];
  };
  __proto.getItemPartByKey = function(partKey) {
    var itemPart;
    this.items.forEach(function(item) {
      var _a;
      (_a = item.parts) === null || _a === void 0 ? void 0 : _a.forEach(function(part) {
        if (part.key === partKey) {
          itemPart = part;
        }
      });
    });
    return itemPart;
  };
  __proto.getScrollSize = function() {
    var items = this.items;
    var length2 = items.length;
    if (!length2) {
      return 0;
    }
    return Math.max.apply(Math, __spreadArray2([0], items[length2 - 1].endOutline, false));
  };
  __proto.getVisibleArea = function(scrollPos, direction) {
    if (direction === void 0) {
      direction = this.options.defaultDirection;
    }
    var isDirectionEnd = direction === DIRECTION.END;
    var visibleItems = this.getRenderedVisibleItems();
    if (!visibleItems.length) {
      return null;
    }
    var visibleItem = visibleItems[isDirectionEnd ? 0 : length - 1];
    var itemPos = isDirectionEnd ? Math.min.apply(Math, visibleItem.startOutline) : Math.max.apply(Math, visibleItem.endOutline);
    var pos = itemPos;
    var itemPart;
    if (isDirectionEnd) {
      visibleItems.forEach(function(item) {
        var _a;
        (_a = item.parts) === null || _a === void 0 ? void 0 : _a.forEach(function(part) {
          if (itemPart && itemPart.pos >= part.pos) {
            return;
          }
          if (pos < part.pos && part.pos <= scrollPos) {
            itemPart = part;
            pos = part.pos;
          }
        });
      });
    } else {
      visibleItems.forEach(function(item) {
        var _a;
        (_a = item.parts) === null || _a === void 0 ? void 0 : _a.forEach(function(part) {
          var endPos = part.pos + part.size;
          if (itemPart && itemPart.pos + itemPart.size <= endPos) {
            return;
          }
          if (pos > endPos && endPos >= scrollPos) {
            itemPart = part;
            pos = endPos;
          }
        });
      });
    }
    return {
      item: visibleItem,
      part: itemPart
    };
  };
  __proto.getRenderedVisibleItems = function() {
    var items = this.getVisibleItems();
    var rendered = items.map(function(_a) {
      var startOutline = _a.startOutline, endOutline = _a.endOutline;
      var length2 = startOutline.length;
      if (length2 === 0 || length2 !== endOutline.length) {
        return false;
      }
      return startOutline.some(function(pos, i) {
        return endOutline[i] !== pos;
      });
    });
    var startIndex = rendered.indexOf(true);
    var endIndex = rendered.lastIndexOf(true);
    return endIndex === -1 ? [] : items.slice(startIndex, endIndex + 1);
  };
  __proto.destroy = function() {
    this.off();
    this.startCursor = -1;
    this.endCursor = -1;
    this.items = [];
    this.size = 0;
  };
  return Infinite2;
}(component_esm_default);
var Renderer = function(_super) {
  __extends5(Renderer2, _super);
  function Renderer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.items = [];
    _this.container = null;
    _this.rendererKey = 0;
    _this._updateTimer = 0;
    _this._state = {};
    _this._isItemChanged = false;
    return _this;
  }
  var __proto = Renderer2.prototype;
  __proto.updateKey = function() {
    this.rendererKey = Date.now();
  };
  __proto.getItems = function() {
    return this.items;
  };
  __proto.setContainer = function(container) {
    this.container = container;
  };
  __proto.render = function(nextItems, state) {
    return this.syncItems(nextItems, state);
  };
  __proto.update = function(state) {
    var _this = this;
    if (state === void 0) {
      state = {};
    }
    this._state = __assign3(__assign3({}, this._state), state);
    this.trigger("update", {
      state
    });
    clearTimeout(this._updateTimer);
    this._updateTimer = window.setTimeout(function() {
      _this.trigger("requestUpdate", {
        state
      });
    });
  };
  __proto.updated = function(nextElements) {
    var _a, _b;
    if (nextElements === void 0) {
      nextElements = (_b = (_a = this.container) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    }
    var diffResult = this._diffResult;
    var isChanged = !!(diffResult.added.length || diffResult.removed.length || diffResult.changed.length);
    var state = this._state;
    var isItemChanged = this._isItemChanged;
    var nextItems = diffResult.list;
    this._isItemChanged = false;
    this._state = {};
    this.items = nextItems;
    nextItems.forEach(function(item, i) {
      item.element = nextElements[i];
    });
    this.trigger("updated", {
      items: nextItems,
      elements: toArray2(nextElements),
      diffResult: this._diffResult,
      state,
      isItemChanged,
      isChanged
    });
    return isChanged;
  };
  __proto.syncItems = function(items, state) {
    if (state === void 0) {
      state = {};
    }
    var rendererKey = this.rendererKey;
    var prevItems = this.items;
    var nextItems = items.map(function(item) {
      return __assign3(__assign3({}, item), {
        renderKey: "".concat(rendererKey, "_").concat(item.key)
      });
    });
    var result = diff(prevItems, nextItems, function(item) {
      return item.renderKey;
    });
    this._isItemChanged = !!result.added.length || !!result.removed.length || !!result.changed.length;
    this._state = __assign3(__assign3({}, this._state), state);
    this._diffResult = result;
    return result;
  };
  __proto.destroy = function() {
    this.off();
  };
  return Renderer2;
}(component_esm_default);
var VanillaRenderer = function(_super) {
  __extends5(VanillaRenderer2, _super);
  function VanillaRenderer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = VanillaRenderer2.prototype;
  __proto.render = function(nextItems, state) {
    var container = this.container;
    var result = _super.prototype.render.call(this, nextItems, state);
    var prevList = result.prevList, removed = result.removed, ordered = result.ordered, added = result.added, list = result.list;
    var diffList = __spreadArray2([], prevList, true);
    removed.forEach(function(index) {
      diffList.splice(index, 1);
      container.removeChild(prevList[index].element);
    });
    ordered.forEach(function(_a) {
      var _b, _c;
      var prevIndex = _a[0], nextIndex = _a[1];
      var item = diffList.splice(prevIndex, 1)[0];
      diffList.splice(nextIndex, 0, item);
      container.insertBefore(item.element, (_c = (_b = diffList[nextIndex + 1]) === null || _b === void 0 ? void 0 : _b.element) !== null && _c !== void 0 ? _c : null);
    });
    added.forEach(function(index) {
      var _a, _b;
      var item = list[index];
      diffList.splice(index, 0, item);
      container.insertBefore(item.element, (_b = (_a = diffList[index + 1]) === null || _a === void 0 ? void 0 : _a.element) !== null && _b !== void 0 ? _b : null);
    });
    this.updated(container.children);
    return result;
  };
  return VanillaRenderer2;
}(Renderer);
var VanillaGridRenderer = function(_super) {
  __extends5(VanillaGridRenderer2, _super);
  function VanillaGridRenderer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = VanillaGridRenderer2.prototype;
  __proto.syncItems = function(nextItems) {
    var result = _super.prototype.syncItems.call(this, nextItems);
    var added = result.added, list = result.list;
    added.forEach(function(index) {
      var orgItem = nextItems[index].orgItem;
      if (orgItem.html && !orgItem.element) {
        orgItem.element = convertHTMLtoElement(orgItem.html)[0];
      }
      list[index].element = orgItem.element;
    });
    return result;
  };
  return VanillaGridRenderer2;
}(VanillaRenderer);
var ScrollManager = function(_super) {
  __extends5(ScrollManager2, _super);
  function ScrollManager2(wrapper, options) {
    var _this = _super.call(this) || this;
    _this.wrapper = wrapper;
    _this.prevScrollPos = null;
    _this.scrollOffset = 0;
    _this.contentSize = 0;
    _this._isScrollIssue = IS_IOS;
    _this._onCheck = function() {
      var prevScrollPos = _this.getScrollPos();
      var nextScrollPos = _this.getOrgScrollPos();
      _this.setScrollPos(nextScrollPos);
      if (prevScrollPos === null || _this._isScrollIssue && nextScrollPos === 0 || prevScrollPos === nextScrollPos) {
        nextScrollPos && (_this._isScrollIssue = false);
        return;
      }
      _this._isScrollIssue = false;
      _this.trigger(new ComponentEvent$1("scroll", {
        direction: prevScrollPos < nextScrollPos ? "end" : "start",
        scrollPos: nextScrollPos,
        relativeScrollPos: _this.getRelativeScrollPos()
      }));
    };
    _this.options = __assign3({
      container: false,
      containerTag: "div",
      horizontal: false,
      scrollContainer: null
    }, options);
    _this._init();
    return _this;
  }
  var __proto = ScrollManager2.prototype;
  __proto.getWrapper = function() {
    return this.wrapper;
  };
  __proto.getContainer = function() {
    return this.container;
  };
  __proto.getScrollContainer = function() {
    return this.scrollContainer;
  };
  __proto.getScrollOffset = function() {
    return this.scrollOffset;
  };
  __proto.getContentSize = function() {
    return this.contentSize;
  };
  __proto.getRelativeScrollPos = function() {
    return (this.prevScrollPos || 0) - this.scrollOffset;
  };
  __proto.getScrollPos = function() {
    return this.prevScrollPos;
  };
  __proto.setScrollPos = function(pos) {
    this.prevScrollPos = pos;
  };
  __proto.getOrgScrollPos = function() {
    var eventTarget = this.eventTarget;
    var horizontal = this.options.horizontal;
    var prop = "scroll".concat(horizontal ? "Left" : "Top");
    if (isWindow2(eventTarget)) {
      return window[horizontal ? "pageXOffset" : "pageYOffset"] || document.documentElement[prop] || document.body[prop];
    } else {
      return eventTarget[prop];
    }
  };
  __proto.setStatus = function(status) {
    this.contentSize = status.contentSize;
    this.scrollOffset = status.scrollOffset;
    this.prevScrollPos = status.prevScrollPos;
    this.scrollTo(this.prevScrollPos);
  };
  __proto.getStatus = function() {
    return {
      contentSize: this.contentSize,
      scrollOffset: this.scrollOffset,
      prevScrollPos: this.prevScrollPos
    };
  };
  __proto.scrollTo = function(pos) {
    var eventTarget = this.eventTarget;
    var horizontal = this.options.horizontal;
    var _a = horizontal ? [pos, 0] : [0, pos], x = _a[0], y = _a[1];
    if (isWindow2(eventTarget)) {
      eventTarget.scroll(x, y);
    } else {
      eventTarget.scrollLeft = x;
      eventTarget.scrollTop = y;
    }
  };
  __proto.scrollBy = function(pos) {
    if (!pos) {
      return;
    }
    var eventTarget = this.eventTarget;
    var horizontal = this.options.horizontal;
    var _a = horizontal ? [pos, 0] : [0, pos], x = _a[0], y = _a[1];
    this.prevScrollPos += pos;
    if (isWindow2(eventTarget)) {
      eventTarget.scrollBy(x, y);
    } else {
      eventTarget.scrollLeft += x;
      eventTarget.scrollTop += y;
    }
  };
  __proto.resize = function() {
    var scrollContainer = this.scrollContainer;
    var horizontal = this.options.horizontal;
    var isBody = scrollContainer === document.body;
    var scrollContainerRect = isBody ? {
      top: 0,
      left: 0
    } : scrollContainer.getBoundingClientRect();
    var containerRect = this.container.getBoundingClientRect();
    this.scrollOffset = (this.getOrgScrollPos() || 0) + (horizontal ? containerRect.left - scrollContainerRect.left : containerRect.top - scrollContainerRect.top);
    if (isBody) {
      this.contentSize = horizontal ? window.innerWidth : window.innerHeight;
    } else {
      this.contentSize = horizontal ? scrollContainer.offsetWidth : scrollContainer.offsetHeight;
    }
  };
  __proto.destroy = function() {
    var container = this.container;
    this.eventTarget.removeEventListener("scroll", this._onCheck);
    if (this._isCreateElement) {
      var scrollContainer = this.scrollContainer;
      var fragment_1 = document.createDocumentFragment();
      var childNodes = toArray2(container.childNodes);
      scrollContainer.removeChild(container);
      childNodes.forEach(function(childNode) {
        fragment_1.appendChild(childNode);
      });
      scrollContainer.appendChild(fragment_1);
    } else if (this.options.container) {
      container.style.cssText = this._orgCSSText;
    }
  };
  __proto._init = function() {
    var _a;
    var _b = this.options, containerOption = _b.container, containerTag = _b.containerTag, horizontal = _b.horizontal, scrollContainerOption = _b.scrollContainer;
    var wrapper = this.wrapper;
    var scrollContainer = wrapper;
    var container = wrapper;
    var containerCSSText = "";
    if (!containerOption) {
      scrollContainer = findTarget(scrollContainerOption) || document.body;
      containerCSSText = container.style.cssText;
    } else {
      if (containerOption === true) {
        container = document.createElement(containerTag);
        container.style.position = "relative";
        container.className = CONTAINER_CLASS_NAME;
        var childNodes = toArray2(scrollContainer.childNodes);
        childNodes.forEach(function(childNode) {
          container.appendChild(childNode);
        });
        scrollContainer.appendChild(container);
        this._isCreateElement = true;
      } else {
        container = findTarget(containerOption);
      }
      containerCSSText = container.style.cssText;
      var style = scrollContainer.style;
      _a = horizontal ? ["scroll", "hidden"] : ["hidden", "scroll"], style.overflowX = _a[0], style.overflowY = _a[1];
      if (horizontal) {
        container.style.height = "100%";
      }
    }
    var eventTarget = scrollContainer === document.body ? window : scrollContainer;
    eventTarget.addEventListener("scroll", this._onCheck);
    this._orgCSSText = containerCSSText;
    this.container = container;
    this.scrollContainer = scrollContainer;
    this.eventTarget = eventTarget;
    this.resize();
    this.setScrollPos(this.getOrgScrollPos());
  };
  return ScrollManager2;
}(component_esm_default);
var InfiniteGrid = function(_super) {
  __extends5(InfiniteGrid3, _super);
  function InfiniteGrid3(wrapper, options) {
    var _this = _super.call(this) || this;
    _this._waitType = "";
    _this._onScroll = function(_a2) {
      var direction = _a2.direction, scrollPos = _a2.scrollPos, relativeScrollPos = _a2.relativeScrollPos;
      _this._scroll();
      _this.trigger(new ComponentEvent$1(INFINITEGRID_EVENTS.CHANGE_SCROLL, {
        direction,
        scrollPos,
        relativeScrollPos
      }));
    };
    _this._onChange = function(e) {
      _this.setCursors(e.nextStartCursor, e.nextEndCursor);
    };
    _this._onRendererUpdated = function(e) {
      var renderedItems = e.items;
      renderedItems.forEach(function(item) {
        var gridItem = item.orgItem;
        gridItem.element = item.element;
      });
      if (!e.isChanged) {
        _this._checkEndLoading();
        _this._scroll();
        return;
      }
      var _a2 = e.diffResult, added = _a2.added, removed = _a2.removed, prevList = _a2.prevList, list = _a2.list;
      removed.forEach(function(index) {
        var orgItem = prevList[index].orgItem;
        if (orgItem.mountState !== MOUNT_STATE.UNCHECKED) {
          orgItem.mountState = MOUNT_STATE.UNMOUNTED;
        }
      });
      var horizontal2 = _this.options.horizontal;
      var addedItems = added.map(function(index) {
        var gridItem = list[index].orgItem;
        var element = gridItem.element;
        if (gridItem.type === ITEM_TYPE.VIRTUAL) {
          var cssRect = __assign3({}, gridItem.cssRect);
          var rect = gridItem.rect;
          if (!cssRect.width && rect.width) {
            cssRect.width = rect.width;
          }
          if (!cssRect.height && rect.height) {
            cssRect.height = rect.height;
          }
          return new GridItem(horizontal2, {
            element,
            cssRect
          });
        }
        return gridItem;
      });
      var containerManager2 = _this.containerManager;
      if (_this.options.observeChildren) {
        containerManager2.unobserveChildren(removed.map(function(index) {
          return prevList[index].element;
        }));
        containerManager2.observeChildren(added.map(function(index) {
          return list[index].element;
        }));
      }
      var _b = e.state, isRestore = _b.isRestore, isResize = _b.isResize;
      _this.itemRenderer.renderItems(addedItems);
      if (isRestore) {
        _this._onRenderComplete({
          mounted: added.map(function(index) {
            return list[index].orgItem;
          }),
          updated: [],
          isResize: false,
          direction: _this.defaultDirection
        });
      }
      if (!isRestore || isResize || e.isItemChanged) {
        _this.groupManager.renderItems();
      }
    };
    _this._onResize = function(e) {
      if (e.isResizeContainer) {
        _this._renderItems({
          useResize: true
        }, true);
      } else {
        var updatedItems = getUpdatedItems(_this.getVisibleItems(), e.childEntries);
        if (updatedItems.length > 0) {
          _this.updateItems(updatedItems);
        }
      }
    };
    _this._onRequestAppend = function(e) {
      _this._onRequestInsert(DIRECTION.END, INFINITEGRID_EVENTS.REQUEST_APPEND, e);
    };
    _this._onRequestPrepend = function(e) {
      _this._onRequestInsert(DIRECTION.START, INFINITEGRID_EVENTS.REQUEST_PREPEND, e);
    };
    _this._onContentError = function(_a2) {
      var element = _a2.element, target = _a2.target, item = _a2.item, update = _a2.update;
      _this.trigger(new ComponentEvent$1(INFINITEGRID_EVENTS.CONTENT_ERROR, {
        element,
        target,
        item,
        update,
        remove: function() {
          _this.removeByKey(item.key);
        }
      }));
    };
    _this._onRenderComplete = function(_a2) {
      var isResize = _a2.isResize, mounted = _a2.mounted, updated = _a2.updated, direction = _a2.direction;
      var infinite2 = _this.infinite;
      var scrollManager2 = _this.scrollManager;
      var scrollPos = scrollManager2.getRelativeScrollPos();
      var prevScrollSize = infinite2.getScrollSize();
      var prevContainerSize = infinite2.getSize();
      var prevVisibleArea = infinite2.getVisibleArea(scrollPos, direction);
      var isDirectionEnd = direction === DIRECTION.END;
      _this._syncInfinite();
      if (prevVisibleArea) {
        var prevPart = prevVisibleArea.part;
        var prevItem = prevVisibleArea.item;
        var nextPart = void 0;
        var nextItem = void 0;
        if (prevPart) {
          nextPart = infinite2.getItemPartByKey(prevPart.key);
        }
        if (prevItem) {
          nextItem = infinite2.getItemByKey(prevItem.key);
        }
        if (nextPart || nextItem) {
          var prevPos = 0;
          var nextPos = 0;
          if (nextPart) {
            nextPos = nextPart.pos + (isDirectionEnd ? 0 : nextPart.size);
            prevPos = prevPart.pos + (isDirectionEnd ? 0 : prevPart.size);
          } else {
            var prevStartPos = Math.min.apply(Math, prevItem.startOutline);
            var prevEndPos = Math.max.apply(Math, prevItem.endOutline);
            var nextStartPos = Math.min.apply(Math, nextItem.startOutline);
            var nextEndPos = Math.max.apply(Math, nextItem.endOutline);
            nextPos = isDirectionEnd ? nextStartPos : nextEndPos;
            prevPos = isDirectionEnd ? prevStartPos : prevEndPos;
          }
          var offset = nextPos - prevPos;
          if (offset < 0) {
            var nextScrollSize = infinite2.getScrollSize();
            var nextContainerSize = infinite2.getSize();
            var endOffset = Math.max(scrollPos - Math.max(0, prevScrollSize - prevContainerSize), 0);
            var nextScollPos = Math.min(scrollPos, Math.max(0, nextScrollSize - nextContainerSize)) + endOffset;
            offset += scrollPos - nextScollPos;
          }
          _this.scrollManager.scrollBy(offset);
        }
      }
      var completeMounted = mounted.filter(function(item) {
        return item.type !== ITEM_TYPE.LOADING;
      });
      _this.trigger(new ComponentEvent$1(INFINITEGRID_EVENTS.RENDER_COMPLETE, {
        isResize,
        direction,
        mounted: completeMounted,
        updated: updated.filter(function(item) {
          return item.type !== ITEM_TYPE.LOADING;
        }),
        startCursor: _this.getStartCursor(),
        endCursor: _this.getEndCursor(),
        items: _this.getVisibleItems(true),
        groups: _this.getVisibleGroups(true)
      }));
      var isUpdate = _this.groupManager.shouldRerenderItems();
      if (completeMounted.length || updated.length) {
        isUpdate || (isUpdate = !!_this.groupManager.endLoading());
      }
      if (isUpdate) {
        _this._update();
      } else {
        _this._checkEndLoading();
        _this._scroll();
      }
    };
    _this.options = __assign3(__assign3(__assign3({}, _this.constructor.defaultOptions), {
      renderer: new VanillaGridRenderer().on("requestUpdate", function() {
        return _this._render();
      })
    }), options);
    var _a = _this.options, gridConstructor = _a.gridConstructor, containerTag = _a.containerTag, container = _a.container, renderer = _a.renderer, threshold = _a.threshold, useRecycle = _a.useRecycle, scrollContainer = _a.scrollContainer, appliedItemChecker = _a.appliedItemChecker, gridOptions = __rest(_a, ["gridConstructor", "containerTag", "container", "renderer", "threshold", "useRecycle", "scrollContainer", "appliedItemChecker"]);
    var horizontal = gridOptions.horizontal, attributePrefix = gridOptions.attributePrefix, useTransform = gridOptions.useTransform, percentage = gridOptions.percentage, isConstantSize = gridOptions.isConstantSize, isEqualSize = gridOptions.isEqualSize, autoResize = gridOptions.autoResize, useResizeObserver = gridOptions.useResizeObserver, resizeDebounce = gridOptions.resizeDebounce, maxResizeDebounce = gridOptions.maxResizeDebounce, defaultDirection = gridOptions.defaultDirection, useRoundedSize = gridOptions.useRoundedSize;
    var wrapperElement = isString4(wrapper) ? document.querySelector(wrapper) : wrapper;
    var scrollManager = new ScrollManager(wrapperElement, {
      scrollContainer,
      container,
      containerTag,
      horizontal
    }).on({
      scroll: _this._onScroll
    });
    var containerElement = scrollManager.getContainer();
    var containerManager = new ContainerManager(containerElement, {
      horizontal,
      autoResize,
      resizeDebounce,
      maxResizeDebounce,
      useResizeObserver
    }).on("resize", _this._onResize);
    var itemRenderer = new ItemRenderer({
      attributePrefix,
      horizontal,
      useTransform,
      percentage,
      isEqualSize,
      isConstantSize,
      useRoundedSize
    });
    var infinite = new Infinite({
      defaultDirection,
      useRecycle,
      threshold
    }).on({
      "change": _this._onChange,
      "requestAppend": _this._onRequestAppend,
      "requestPrepend": _this._onRequestPrepend
    });
    infinite.setSize(scrollManager.getContentSize());
    var groupManager = new GroupManager(containerElement, {
      appliedItemChecker,
      gridConstructor,
      externalItemRenderer: itemRenderer,
      externalContainerManager: containerManager,
      gridOptions
    });
    groupManager.on({
      "renderComplete": _this._onRenderComplete,
      "contentError": _this._onContentError
    });
    renderer.setContainer(containerElement);
    renderer.on("updated", _this._onRendererUpdated);
    _this.itemRenderer = itemRenderer;
    _this.groupManager = groupManager;
    _this.wrapperElement = wrapperElement;
    _this.scrollManager = scrollManager;
    _this.containerManager = containerManager;
    _this.infinite = infinite;
    _this.containerManager.resize();
    return _this;
  }
  var __proto = InfiniteGrid3.prototype;
  InfiniteGrid_1 = InfiniteGrid3;
  __proto.renderItems = function(options) {
    if (options === void 0) {
      options = {};
    }
    this._renderItems(options);
    return this;
  };
  __proto.getWrapperElement = function() {
    return this.scrollManager.getWrapper();
  };
  __proto.getScrollContainerElement = function() {
    return this.scrollManager.getScrollContainer();
  };
  __proto.getContainerElement = function() {
    return this.scrollManager.getContainer();
  };
  __proto.syncItems = function(items) {
    this.groupManager.syncItems(items);
    this._syncGroups();
    return this;
  };
  __proto.setCursors = function(startCursor, endCursor, useFirstRender) {
    this.groupManager.setCursors(startCursor, endCursor);
    this.infinite.setCursors(startCursor, endCursor);
    if (useFirstRender) {
      this.getVisibleItems().forEach(function(item) {
        if (item.cssRect.top === INVISIBLE_POS) {
          item.cssRect = {};
        }
      });
      this._syncItems();
    } else {
      this._update();
      this._checkEndLoading();
    }
    return this;
  };
  __proto.getStartCursor = function() {
    return this.infinite.getStartCursor();
  };
  __proto.getEndCursor = function() {
    return this.infinite.getEndCursor();
  };
  __proto.append = function(items, groupKey) {
    return this.insert(-1, items, groupKey);
  };
  __proto.prepend = function(items, groupKey) {
    return this.insert(0, items, groupKey);
  };
  __proto.insert = function(index, items, groupKey) {
    var nextItemInfos = this.groupManager.getGroupItems();
    var itemInfos = convertInsertedItems(items, groupKey);
    if (index === -1) {
      nextItemInfos.push.apply(nextItemInfos, itemInfos);
    } else {
      nextItemInfos.splice.apply(nextItemInfos, __spreadArray2([index, 0], itemInfos, false));
    }
    return this.syncItems(nextItemInfos);
  };
  __proto.insertByGroupIndex = function(groupIndex, items, groupKey) {
    var nextGroupInfos = this.groupManager.getGroups();
    var rightGroup = nextGroupInfos[groupIndex];
    if (!rightGroup) {
      return this.append(items, groupKey);
    }
    var nextItemInfos = this.groupManager.getGroupItems();
    var rightGroupKey = rightGroup.groupKey;
    var rightItemIndex = findIndex(nextItemInfos, function(item) {
      return item.groupKey === rightGroupKey;
    });
    return this.insert(rightItemIndex, items, groupKey);
  };
  __proto.getStatus = function(type, includePlaceholders) {
    return {
      containerManager: this.containerManager.getStatus(),
      itemRenderer: this.itemRenderer.getStatus(),
      groupManager: this.groupManager.getGroupStatus(type, includePlaceholders),
      scrollManager: this.scrollManager.getStatus()
    };
  };
  __proto.setPlaceholder = function(info) {
    this.groupManager.setPlaceholder(info);
    return this;
  };
  __proto.setLoading = function(info) {
    this.groupManager.setLoading(info);
    return this;
  };
  __proto.appendPlaceholders = function(items, groupKey) {
    var _this = this;
    var result = this.groupManager.appendPlaceholders(items, groupKey);
    this._syncGroups(true);
    return __assign3(__assign3({}, result), {
      remove: function() {
        _this.removePlaceholders({
          groupKey: result.group.groupKey
        });
      }
    });
  };
  __proto.prependPlaceholders = function(items, groupKey) {
    var _this = this;
    var result = this.groupManager.prependPlaceholders(items, groupKey);
    this._syncGroups(true);
    return __assign3(__assign3({}, result), {
      remove: function() {
        _this.removePlaceholders({
          groupKey: result.group.groupKey
        });
      }
    });
  };
  __proto.removePlaceholders = function(type) {
    this.groupManager.removePlaceholders(type);
    this._syncGroups(true);
  };
  __proto.setStatus = function(status, useFirstRender) {
    this.itemRenderer.setStatus(status.itemRenderer);
    this.containerManager.setStatus(status.containerManager);
    this.scrollManager.setStatus(status.scrollManager);
    var groupManager = this.groupManager;
    var prevInlineSize = this.containerManager.getInlineSize();
    groupManager.setGroupStatus(status.groupManager);
    this._syncInfinite();
    this.infinite.setCursors(groupManager.getStartCursor(), groupManager.getEndCursor());
    this._getRenderer().updateKey();
    var state = {
      isResize: this.containerManager.getInlineSize() !== prevInlineSize,
      isRestore: true
    };
    if (useFirstRender) {
      this._syncItems(state);
    } else {
      this._update(state);
    }
    return this;
  };
  __proto.removeGroupByIndex = function(index) {
    var nextGroups = this.getGroups();
    return this.removeGroupByKey(nextGroups[index].groupKey);
  };
  __proto.removeGroupByKey = function(key) {
    var nextItemInfos = this.getItems();
    var firstIndex = findIndex(nextItemInfos, function(item) {
      return item.groupKey === key;
    });
    var lastIndex = findLastIndex(nextItemInfos, function(item) {
      return item.groupKey === key;
    });
    if (firstIndex === -1) {
      return this;
    }
    nextItemInfos.splice(firstIndex, lastIndex - firstIndex + 1);
    return this.syncItems(nextItemInfos);
  };
  __proto.removeByIndex = function(index) {
    var nextItemInfos = this.getItems(true);
    nextItemInfos.splice(index, 1);
    return this.syncItems(nextItemInfos);
  };
  __proto.removeByKey = function(key) {
    var nextItemInfos = this.getItems(true);
    var index = findIndex(nextItemInfos, function(item) {
      return item.key === key;
    });
    return this.removeByIndex(index);
  };
  __proto.updateItems = function(items, options) {
    if (options === void 0) {
      options = {};
    }
    this.groupManager.updateItems(items, options);
    return this;
  };
  __proto.getItems = function(includePlaceholders) {
    return this.groupManager.getGroupItems(includePlaceholders);
  };
  __proto.getVisibleItems = function(includePlaceholders) {
    return this.groupManager.getVisibleItems(includePlaceholders);
  };
  __proto.getRenderingItems = function() {
    return this.groupManager.getRenderingItems();
  };
  __proto.getGroups = function(includePlaceholders) {
    return this.groupManager.getGroups(includePlaceholders);
  };
  __proto.getVisibleGroups = function(includePlaceholders) {
    return this.groupManager.getVisibleGroups(includePlaceholders);
  };
  __proto.wait = function(direction) {
    if (direction === void 0) {
      direction = DIRECTION.END;
    }
    this._waitType = direction;
    this._checkStartLoading(direction);
  };
  __proto.ready = function(hasNoData) {
    this._waitType = "";
    if (hasNoData) {
      this.groupManager.waitEndLoading();
      if (this.groupManager.endLoading()) {
        this._update();
      }
    }
  };
  __proto.isWait = function() {
    return !!this._waitType;
  };
  __proto.destroy = function() {
    this.off();
    this._getRenderer().destroy();
    this.containerManager.destroy();
    this.groupManager.destroy();
    this.scrollManager.destroy();
    this.infinite.destroy();
  };
  __proto._getRenderer = function() {
    return this.options.renderer;
  };
  __proto._getRendererItems = function() {
    return this.getRenderingItems().map(function(item) {
      return {
        element: item.element,
        key: "".concat(item.type, "_").concat(item.key),
        orgItem: item
      };
    });
  };
  __proto._syncItems = function(state) {
    this._getRenderer().syncItems(this._getRendererItems(), state);
  };
  __proto._render = function(state) {
    this._getRenderer().render(this._getRendererItems(), state);
  };
  __proto._update = function(state) {
    if (state === void 0) {
      state = {};
    }
    this._getRenderer().update(state);
  };
  __proto._resizeScroll = function() {
    var scrollManager = this.scrollManager;
    scrollManager.resize();
    this.infinite.setSize(scrollManager.getContentSize());
  };
  __proto._syncGroups = function(isUpdate) {
    var infinite = this.infinite;
    var scrollManager = this.scrollManager;
    if (!scrollManager.getContentSize()) {
      this._resizeScroll();
    }
    this._syncInfinite();
    this.groupManager.setCursors(infinite.getStartCursor(), infinite.getEndCursor());
    if (isUpdate) {
      this._update();
    } else {
      this._render();
    }
  };
  __proto._syncInfinite = function() {
    this.infinite.syncItems(this.getGroups(true).map(function(_a) {
      var groupKey = _a.groupKey, grid = _a.grid, type = _a.type;
      var outlines = grid.getOutlines();
      return {
        key: groupKey,
        isVirtual: type === GROUP_TYPE.VIRTUAL,
        startOutline: outlines.start,
        endOutline: outlines.end,
        parts: grid.getItems().map(function(item) {
          return {
            key: item.key,
            pos: item.computedContentPos,
            size: item.computedContentSize
          };
        })
      };
    }));
  };
  __proto._scroll = function() {
    this.infinite.scroll(this.scrollManager.getRelativeScrollPos());
  };
  __proto._onRequestInsert = function(direction, eventType, e) {
    var _this = this;
    if (this._waitType) {
      this._checkStartLoading(this._waitType);
      return;
    }
    this.trigger(new ComponentEvent$1(eventType, {
      groupKey: e.key,
      nextGroupKey: e.nextKey,
      nextGroupKeys: e.nextKeys || [],
      isVirtual: e.isVirtual,
      wait: function() {
        _this.wait(direction);
      },
      ready: function(hasNoData) {
        _this.ready(hasNoData);
      }
    }));
  };
  __proto._renderItems = function(options, isTrusted) {
    if (options === void 0) {
      options = {};
    }
    if (!isTrusted && options.useResize) {
      this.containerManager.resize();
    }
    this._resizeScroll();
    if (!this.getRenderingItems().length) {
      var children = toArray2(this.getContainerElement().children);
      if (children.length > 0) {
        this.groupManager.syncItems(convertInsertedItems(children));
        this._syncInfinite();
        this.setCursors(0, 0, true);
        this._getRenderer().updated();
      } else {
        this.infinite.scroll(0);
      }
      return this;
    }
    if (!this.getVisibleGroups(true).length) {
      this.setCursors(0, 0);
    } else {
      this.groupManager.renderItems(options);
    }
    return this;
  };
  __proto._checkStartLoading = function(direction) {
    var groupManager = this.groupManager;
    var infinite = this.infinite;
    if (!groupManager.getLoadingType() && infinite.isLoading(direction) && groupManager.startLoading(direction) && groupManager.hasLoadingItem()) {
      this._update();
    }
  };
  __proto._checkEndLoading = function() {
    var groupManager = this.groupManager;
    var loadingType = this.groupManager.getLoadingType();
    if (loadingType && (!this._waitType || !this.infinite.isLoading(loadingType)) && groupManager.waitEndLoading() && groupManager.hasLoadingItem()) {
      this._update();
    }
  };
  var InfiniteGrid_1;
  InfiniteGrid3.defaultOptions = __assign3(__assign3({}, DEFAULT_GRID_OPTIONS), {
    container: false,
    containerTag: "div",
    renderer: null,
    threshold: 100,
    useRecycle: true,
    scrollContainer: null,
    appliedItemChecker: function() {
      return false;
    }
  });
  InfiniteGrid3.propertyTypes = INFINITEGRID_PROPERTY_TYPES;
  InfiniteGrid3 = InfiniteGrid_1 = __decorate2([InfiniteGridGetterSetter], InfiniteGrid3);
  return InfiniteGrid3;
}(component_esm_default);
var MasonryInfiniteGrid = function(_super) {
  __extends5(MasonryInfiniteGrid3, _super);
  function MasonryInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MasonryInfiniteGrid3.propertyTypes = __assign3(__assign3({}, InfiniteGrid.propertyTypes), MasonryGrid.propertyTypes);
  MasonryInfiniteGrid3.defaultOptions = __assign3(__assign3(__assign3({}, InfiniteGrid.defaultOptions), MasonryGrid.defaultOptions), {
    gridConstructor: MasonryGrid,
    appliedItemChecker: function(item, grid) {
      var column = parseFloat(item.attributes.column) || 0;
      return column >= grid.outlineLength;
    }
  });
  MasonryInfiniteGrid3 = __decorate2([InfiniteGridGetterSetter], MasonryInfiniteGrid3);
  return MasonryInfiniteGrid3;
}(InfiniteGrid);
var JustifiedInfiniteGrid = function(_super) {
  __extends5(JustifiedInfiniteGrid3, _super);
  function JustifiedInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  JustifiedInfiniteGrid3.propertyTypes = __assign3(__assign3({}, InfiniteGrid.propertyTypes), JustifiedGrid.propertyTypes);
  JustifiedInfiniteGrid3.defaultOptions = __assign3(__assign3(__assign3({}, InfiniteGrid.defaultOptions), JustifiedGrid.defaultOptions), {
    gridConstructor: JustifiedGrid
  });
  JustifiedInfiniteGrid3 = __decorate2([InfiniteGridGetterSetter], JustifiedInfiniteGrid3);
  return JustifiedInfiniteGrid3;
}(InfiniteGrid);
var FrameInfiniteGrid = function(_super) {
  __extends5(FrameInfiniteGrid3, _super);
  function FrameInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  FrameInfiniteGrid3.propertyTypes = __assign3(__assign3({}, InfiniteGrid.propertyTypes), FrameGrid.propertyTypes);
  FrameInfiniteGrid3.defaultOptions = __assign3(__assign3(__assign3({}, InfiniteGrid.defaultOptions), FrameGrid.defaultOptions), {
    gridConstructor: FrameGrid
  });
  FrameInfiniteGrid3 = __decorate2([InfiniteGridGetterSetter], FrameInfiniteGrid3);
  return FrameInfiniteGrid3;
}(InfiniteGrid);
var PackingInfiniteGrid = function(_super) {
  __extends5(PackingInfiniteGrid3, _super);
  function PackingInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PackingInfiniteGrid3.propertyTypes = __assign3(__assign3({}, InfiniteGrid.propertyTypes), PackingGrid.propertyTypes);
  PackingInfiniteGrid3.defaultOptions = __assign3(__assign3(__assign3({}, InfiniteGrid.defaultOptions), PackingGrid.defaultOptions), {
    gridConstructor: PackingGrid
  });
  PackingInfiniteGrid3 = __decorate2([InfiniteGridGetterSetter], PackingInfiniteGrid3);
  return PackingInfiniteGrid3;
}(InfiniteGrid);
var infinitegrid_esm_default = InfiniteGrid;

// node_modules/@egjs/react-infinitegrid/dist/infinitegrid.esm.js
var extendStatics6 = function(d, b) {
  extendStatics6 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics6(d, b);
};
function __extends6(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics6(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign4 = function() {
  __assign4 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray3(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var REACT_INFINITEGRID_EVENT_MAP = {
  "onContentError": "contentError",
  "onRenderComplete": "renderComplete",
  "onRequestAppend": "requestAppend",
  "onRequestPrepend": "requestPrepend",
  "onChangeScroll": "changeScroll"
};
var REACT_INFINITEGRID_EVENTS = [];
for (name in REACT_INFINITEGRID_EVENT_MAP) {
  REACT_INFINITEGRID_EVENTS.push(name);
}
var name;
var REACT_INFINITEGRID_PROPS = __spreadArray3(["tag", "placeholder", "status", "useFirstRender", "loading", "itemBy", "groupBy", "infoBy"], REACT_INFINITEGRID_EVENTS, true);
function isFunction(val) {
  return typeof val === "function";
}
var InfiniteGrid2 = function(_super) {
  __extends6(InfiniteGrid3, _super);
  function InfiniteGrid3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._wrapperRef = (0, import_react.createRef)();
    _this._containerRef = (0, import_react.createRef)();
    return _this;
  }
  var __proto = InfiniteGrid3.prototype;
  __proto.render = function() {
    var attributes = {};
    var props = this.props;
    var GridClass = this.constructor.GridClass;
    var defaultOptions = GridClass.defaultOptions;
    var Tag = props.tag || "div";
    for (var name in props) {
      if (name in defaultOptions || REACT_INFINITEGRID_PROPS.indexOf(name) > -1) {
        continue;
      }
      attributes[name] = props[name];
    }
    return (0, import_react.createElement)(Tag, __assign4({
      ref: this._wrapperRef
    }, attributes), this._renderContainer());
  };
  __proto.componentDidMount = function() {
    var _this = this;
    var GridClass = this.constructor.GridClass;
    var defaultOptions = GridClass.defaultOptions;
    var options = {};
    var props = this.props;
    var containerElement = this._containerRef.current;
    for (var name in defaultOptions) {
      if (name in props) {
        options[name] = props[name];
      }
    }
    if (containerElement) {
      options.container = containerElement;
    }
    this._renderer = new Renderer();
    options.renderer = this._renderer;
    var grid = new GridClass(this._wrapperRef.current, options);
    var _loop_1 = function(eventName2) {
      var nativeEventName = REACT_INFINITEGRID_EVENT_MAP[eventName2];
      grid.on(nativeEventName, function(e) {
        var callback = _this.props[eventName2];
        callback && callback(e);
      });
    };
    for (var eventName in REACT_INFINITEGRID_EVENT_MAP) {
      _loop_1(eventName);
    }
    this._grid = grid;
    this._renderer.on("update", function() {
      _this.setState({});
    });
    mountRenderingItems(this._getItemInfos(), {
      grid,
      useFirstRender: props.useFirstRender,
      useLoading: props.loading,
      usePlaceholder: props.placeholder,
      horizontal: props.horizontal,
      status: props.status
    });
    this._renderer.updated();
  };
  __proto.componentDidUpdate = function() {
    var GridClass = this.constructor.GridClass;
    var propertyTypes = GridClass.propertyTypes;
    var props = this.props;
    var grid = this._grid;
    for (var name in propertyTypes) {
      if (name in props) {
        grid[name] = props[name];
      }
    }
    this._renderer.updated();
  };
  __proto.componentWillUnmount = function() {
    this._grid.destroy();
  };
  __proto._getItemInfos = function() {
    var props = this.props;
    var children = import_react.Children.toArray(props.children);
    var attributePrefix = props.attributePrefix || infinitegrid_esm_default.defaultOptions.attributePrefix;
    var itemBy = props.itemBy || function(item) {
      return item.key;
    };
    var groupBy = props.groupBy || function(item) {
      return item.props["".concat(attributePrefix, "groupkey")];
    };
    var infoBy = props.infoBy || function() {
      return {};
    };
    return children.map(function(child, i) {
      var _a = infoBy(child, i) || {}, data = _a.data, rest = __rest2(_a, ["data"]);
      return __assign4(__assign4({
        groupKey: groupBy(child, i),
        key: itemBy(child, i)
      }, rest), {
        data: __assign4(__assign4({}, data), {
          jsx: child
        })
      });
    });
  };
  __proto._renderContainer = function() {
    var props = this.props;
    var visibleChildren = this._getVisibleChildren();
    var container = props.container;
    var ContainerTag = props.containerTag || "div";
    if (container === true) {
      return (0, import_react.createElement)(ContainerTag, {
        ref: this._containerRef
      }, visibleChildren);
    } else {
      return visibleChildren;
    }
  };
  __proto._getVisibleChildren = function() {
    var props = this.props;
    var placeholder = props.placeholder;
    var loading = props.loading;
    var visibleItems = getRenderingItems(this._getItemInfos(), {
      grid: this._grid,
      status: props.status,
      horizontal: props.horizontal,
      useFirstRender: props.useFirstRender,
      useLoading: props.loading,
      usePlaceholder: props.placeholder
    });
    return visibleItems.map(function(item) {
      if (item.type === ITEM_TYPE.VIRTUAL) {
        return (0, import_react.cloneElement)(isFunction(placeholder) ? placeholder(item) : placeholder, {
          key: item.key
        });
      } else if (item.type === ITEM_TYPE.LOADING) {
        return (0, import_react.cloneElement)(isFunction(loading) ? loading(item) : loading, {
          key: item.key
        });
      } else {
        return item.data.jsx;
      }
    });
  };
  __decorate3([withInfiniteGridMethods], InfiniteGrid3.prototype, "_grid", void 0);
  return InfiniteGrid3;
}(import_react.Component);
var MasonryInfiniteGrid2 = function(_super) {
  __extends6(MasonryInfiniteGrid3, _super);
  function MasonryInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MasonryInfiniteGrid3.GridClass = MasonryInfiniteGrid;
  return MasonryInfiniteGrid3;
}(InfiniteGrid2);
var JustifiedInfiniteGrid2 = function(_super) {
  __extends6(JustifiedInfiniteGrid3, _super);
  function JustifiedInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  JustifiedInfiniteGrid3.GridClass = JustifiedInfiniteGrid;
  return JustifiedInfiniteGrid3;
}(InfiniteGrid2);
var FrameInfiniteGrid2 = function(_super) {
  __extends6(FrameInfiniteGrid3, _super);
  function FrameInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  FrameInfiniteGrid3.GridClass = FrameInfiniteGrid;
  return FrameInfiniteGrid3;
}(InfiniteGrid2);
var PackingInfiniteGrid2 = function(_super) {
  __extends6(PackingInfiniteGrid3, _super);
  function PackingInfiniteGrid3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PackingInfiniteGrid3.GridClass = PackingInfiniteGrid;
  return PackingInfiniteGrid3;
}(InfiniteGrid2);
export {
  FrameInfiniteGrid2 as FrameInfiniteGrid,
  InfiniteGrid2 as InfiniteGrid,
  JustifiedInfiniteGrid2 as JustifiedInfiniteGrid,
  MasonryInfiniteGrid2 as MasonryInfiniteGrid,
  PackingInfiniteGrid2 as PackingInfiniteGrid
};
/*! Bundled license information:

@egjs/component/dist/component.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@egjs/children-differ/dist/children-differ.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@egjs/grid/dist/grid.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@egjs_react-infinitegrid.js.map
